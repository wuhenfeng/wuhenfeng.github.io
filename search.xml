<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>反序列化问题总结</title>
      <link href="/2022/10/04/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/2022/10/04/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="PHP反序列化"><a href="#PHP反序列化" class="headerlink" title="PHP反序列化"></a>PHP反序列化</h1><hr><h4 id="1-序列化：将变量（通常是数组和对象）转换为可保存或传输的字符串"><a href="#1-序列化：将变量（通常是数组和对象）转换为可保存或传输的字符串" class="headerlink" title="1 序列化：将变量（通常是数组和对象）转换为可保存或传输的字符串"></a>1 <strong>序列化</strong>：将变量（通常是数组和对象）转换为可保存或传输的字符串</h4><h4 id="2-反序列化：在适当的时候把这个字符串再转化成原来的变量（通常是数组和对象）使用。"><a href="#2-反序列化：在适当的时候把这个字符串再转化成原来的变量（通常是数组和对象）使用。" class="headerlink" title="2 反序列化：在适当的时候把这个字符串再转化成原来的变量（通常是数组和对象）使用。"></a><strong>2 反序列化</strong>：在适当的时候把这个字符串再转化成原来的变量（通常是数组和对象）使用。</h4><p>这两个过程结合起来，可以轻松地存储和传输数据，使程序更具维护性。反序列化本身不是漏洞，但如果反序列化的内容可控，就容易导致漏洞</p><h4 id="3-常用函数"><a href="#3-常用函数" class="headerlink" title="3 常用函数"></a>3 常用函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">__construct()  <span class="comment">//当对象创建时触发</span></span><br><span class="line">__destruct()   <span class="comment">//当对象销毁时触发</span></span><br><span class="line">__wakeup()     <span class="comment">//当使用unserialize时触发</span></span><br><span class="line">__sleep()     <span class="comment">//当使用serialize时触发</span></span><br><span class="line">__destruct()  <span class="comment">//当对象被销毁时触发</span></span><br><span class="line">__call()      <span class="comment">//当对象上下文中调用不可访问的方法时触发</span></span><br><span class="line">__get()       <span class="comment">//当访问不可访问或不存在的属性时触发</span></span><br><span class="line">__set()       <span class="comment">//当设置不可访问或不存在属性时触发</span></span><br><span class="line">__toString()  <span class="comment">//当把类当作字符串使用时触发  echo或者拼接字符串或者其他隐式调用该方法的操作都会触发</span></span><br><span class="line">__invoke()    <span class="comment">//当对象调用为函数时触发</span></span><br><span class="line">__callStatic  <span class="comment">//是调用类不存在的静态方式方法时执行</span></span><br></pre></td></tr></table></figure><p>这是一个反序列化结果：  &#x2F;&#x2F;O:4:”Test”:2:{s:4:”test”;s:2:”ok”;s:3:”var”;N;}</p><p>O代表这是一个对象，4代表对象名称的长度，2代表成员个数。 “Test”代表类的名称<br>大括号中分别是：属性名类型、长度、名称;值类型、长度、值。“test”代表属性名称</p><p><img src="/2022/10/04/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/6.png"></p><p><strong>要点：</strong></p><p><strong>注意</strong>：反序列时需要注意私有的、被保护的属性被序列化的时候属性值会变成%00*%00属性名（受保护的）。</p><p>所以在构造a参数值的时候，注意序列化后的结构（可能%00类名%00属性名：私有的）</p><h4 id="4-Session序列化问题"><a href="#4-Session序列化问题" class="headerlink" title="4 Session序列化问题"></a>4 Session序列化问题</h4><h4 id="5-Phar反序列化问题"><a href="#5-Phar反序列化问题" class="headerlink" title="5 Phar反序列化问题"></a>5 Phar反序列化问题</h4><h4 id="6-POP链子类问题"><a href="#6-POP链子类问题" class="headerlink" title="6 POP链子类问题"></a>6 POP链子类问题</h4><p>以2022年9月的NewStarCTF week 2的Unseralize为例子</p><h1 id="JAVA反序列化"><a href="#JAVA反序列化" class="headerlink" title="JAVA反序列化"></a>JAVA反序列化</h1><h1 id="Python反序列化"><a href="#Python反序列化" class="headerlink" title="Python反序列化"></a>Python反序列化</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Python语法速通</title>
      <link href="/2022/10/04/Python%E8%AF%AD%E6%B3%95%E9%80%9F%E9%80%9A/"/>
      <url>/2022/10/04/Python%E8%AF%AD%E6%B3%95%E9%80%9F%E9%80%9A/</url>
      
        <content type="html"><![CDATA[<h1 id="python语法"><a href="#python语法" class="headerlink" title="python语法"></a>python语法</h1><hr><ul><li>1 标识符： 只允许出现英文，中文（不推荐，可能会报错），数字(不可以开头)和下划线（_）。</li></ul><p><strong>注意：大小写敏感（区分），不可使用关键字</strong></p><ul><li>转移字符\可以接触引号的效用  例如： “\“黑马程序员\””       三引号用变量接收可以分多行写，不接收就是注释</li><li>字符串拼接： name&#x3D;&#x3D;”黑马程序员”  %d：占位整数  %f：占位小数</li></ul><p>​   massage&#x3D;“学IT: %s ” % name     &#x3D; 学IT： 黑马程序员    </p><p><strong>注意：多个变量占位需要在变量前后加括号</strong></p><hr><ul><li>字符串精度控制：   %7.2f   代表7位整数，2位小数     %5d   表示5位整数</li><li>字符串快速格式化：print（f“名称：{变量}，”）   f： format格式</li></ul><p>注意：不理会类型，不做精度控制（适合对精度无要求的使用）</p><hr><ul><li><strong>注意：无论输入什么，input（）的数据类型都是字符串型</strong></li></ul><hr><ul><li><p>if elif else 注意点： if elif 可以用多个，elif必须带条件，判断是互斥且有序的。 else不用带条件。</p></li><li><p>输出不换行  print（“hello”，end&#x3D;‘’） print （“world”，end&#x3D;‘’）即输出在同一行          print（）为换行</p></li></ul><hr><ul><li>for循环：无法定义循环条件      <strong>{for  临时变量   in   被处理的数据}</strong> 为语法格式   临时变量最好不要在for循坏外部使用</li><li>range语句  语法1：<strong>range （num）从0到num的值</strong>   为1个序列</li><li>语法2：      <strong>range（num1，num2）从1到2的值为1个序列</strong>   </li><li>语法3：      <strong>range（1，2，3）1到2每个按3的方式加  例如5 10 2    序列为{5，7，9}</strong></li></ul><hr><h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><p>def 函数名(传入参数):                 <strong>参数，返回值可以省略</strong>   省略时，可以返回return None</p><p>​  函数体“””  “””三引号可以在有参数的函数里写注释，自动补齐注释格式</p><p>​  return 返回值函数内部的变量不加 global 为局部变量</p><hr><h3 id="数据容器-2022-x2F-9-x2F-29"><a href="#数据容器-2022-x2F-9-x2F-29" class="headerlink" title="数据容器        2022&#x2F;9&#x2F;29"></a>数据容器        2022&#x2F;9&#x2F;29</h3><p>分为5类：列表，元组，字符串，集合，字典。         </p><p>append（元素）插入到结尾             insert（位置，“元素”)插入位置的前一位</p><h5 id="元组tuple-内容不可修改，里面嵌套的list列表可以修改-，语法和列表基本一致"><a href="#元组tuple-内容不可修改，里面嵌套的list列表可以修改-，语法和列表基本一致" class="headerlink" title="元组tuple  内容不可修改，里面嵌套的list列表可以修改 ，语法和列表基本一致"></a>元组tuple  内容不可修改，里面嵌套的list列表可以修改 ，语法和列表基本一致</h5><p>字符串 ：内容不可修改  replace可以替代内容形成一个新的字符串返回值</p><p>集合不支持下表索引，不可会用while循环去遍历</p><p><img src="/2022/10/04/Python%E8%AF%AD%E6%B3%95%E9%80%9F%E9%80%9A/5.png"></p><hr><p>lambda 传入参数：函数体（一行代码）如果不用变量接收，只能每次重写</p><hr><h4 id="文件内容"><a href="#文件内容" class="headerlink" title="文件内容"></a>文件内容</h4><p>read和readlines 两种方法读取文件内容  readline读取一行内容</p><p>对象.read()：表示全部读取  对象.read（num） ：num表示读取多少字节</p><p>对象.close（）：表示关闭文件</p><p>write后需要flush才能有内容，或者直接close有内置flush的功能        （可以创建文件，但也会覆盖内容）</p><p>a模式不会覆盖原文本内容</p><hr><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>import time</p><h5 id="request模块库：主要用来发-送-HTTP-请求"><a href="#request模块库：主要用来发-送-HTTP-请求" class="headerlink" title="request模块库：主要用来发 送 HTTP 请求"></a>request模块库：主要用来发 送 HTTP 请求</h5><table><thead><tr><th>delete(<em>url</em>, <em>args</em>)</th><th>发送 DELETE 请求到指定 url</th></tr></thead><tbody><tr><td>get(<em>url</em>, <em>params, args</em>)</td><td>发送 GET 请求到指定 url</td></tr><tr><td>head(<em>url</em>, <em>args</em>)</td><td>发送 HEAD 请求到指定 url</td></tr><tr><td>patch(<em>url</em>, <em>data, args</em>)</td><td>发送 PATCH 请求到指定 url</td></tr><tr><td>post(<em>url</em>, <em>data, json, args</em>)</td><td>发送 POST 请求到指定 url</td></tr><tr><td>put(<em>url</em>, <em>data, args</em>)</td><td>发送 PUT 请求到指定 url</td></tr><tr><td>request(<em>method</em>, <em>url</em>, <em>args</em>)</td><td>向指定的 url 发送指定的请求方法</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入</title>
      <link href="/2022/10/04/SQL%E6%B3%A8%E5%85%A5/"/>
      <url>/2022/10/04/SQL%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL注入总结"><a href="#SQL注入总结" class="headerlink" title="SQL注入总结"></a>SQL注入总结</h1><h3 id="一：-GET-x2F-POST传参注入-：一般情况下有回显"><a href="#一：-GET-x2F-POST传参注入-：一般情况下有回显" class="headerlink" title="一： GET&#x2F;POST传参注入 ：一般情况下有回显"></a>一： GET&#x2F;POST传参注入 ：一般情况下有回显</h3><p>先判断注入类型：?id&#x3D;1 and 1&#x3D;1   看过滤了(,‘,“,等等。</p><p>然后判断列的个数： ?id&#x3D;1’ order by x – a         以引号闭合为例子，x代表数字，来判断列数</p><h4 id="2-报错注入"><a href="#2-报错注入" class="headerlink" title="2 报错注入"></a>2 报错注入</h4><p>‘ and updatexml(1,concat(0x7e,(select talbe_schema from informaiton_schema.tables where table_schema&#x3D;’库名’limit 0,1),0x7e)1,) –  a   一般形式的字符类报错注入         0x7e为16进制   的  ~  波浪线符号</p><h4 id="3-布尔盲注"><a href="#3-布尔盲注" class="headerlink" title="3 布尔盲注"></a>3 布尔盲注</h4><p>and length(database())&gt;1</p><h4 id="4-时间盲注"><a href="#4-时间盲注" class="headerlink" title="4 时间盲注"></a>4 时间盲注</h4><h4 id="5-二次注入"><a href="#5-二次注入" class="headerlink" title="5 二次注入"></a>5 二次注入</h4><p>通常看到 PHP MySQL_real_escape_string()函数时，这个函数的作用是用来防止数据库被攻击，可以利用二次注入。</p><p>sqli-labs第25关为例子，admin’#创建这个账号后修改密码，由于单引号闭合后，又加了#，注释了后面的密码，所以修改admin’#的密码相当于直接修改了admin的密码，从而得到flag，实现二次注入</p><h4 id="6-宽字节注入：页面和后台的编码不同而产生的漏洞"><a href="#6-宽字节注入：页面和后台的编码不同而产生的漏洞" class="headerlink" title="6 宽字节注入：页面和后台的编码不同而产生的漏洞"></a>6 宽字节注入：页面和后台的编码不同而产生的漏洞</h4><p>‘单引号被过滤了，用%df’来拼接成汉字即可绕过(适用于GET传参时)</p><p>在POST传参时，用bs修改hex文件来达到目的 例如sqli-labs 第34关</p><p>当然，一些汉字（例如：汉）为3个字节时，2个字节一组可以与转义符\相匹配代替%df，从而使转义符失效</p><h4 id="7-堆叠注入：可以使用多个SQL语句，多个查询用分号隔开，这就是产生堆叠注入的原因"><a href="#7-堆叠注入：可以使用多个SQL语句，多个查询用分号隔开，这就是产生堆叠注入的原因" class="headerlink" title="7 堆叠注入：可以使用多个SQL语句，多个查询用分号隔开，这就是产生堆叠注入的原因"></a>7 堆叠注入：可以使用多个SQL语句，多个查询用分号隔开，这就是产生堆叠注入的原因</h4><p>原理看到函数：Mysqli_multi_query()函数时，可以想到堆叠注入</p><h3 id="二-：当存在过滤时，存在的过滤方式"><a href="#二-：当存在过滤时，存在的过滤方式" class="headerlink" title="二 ：当存在过滤时，存在的过滤方式"></a>二 ：当存在过滤时，存在的过滤方式</h3><p><strong>1</strong>   如果过滤了 –  a  和#  注释方式不管用  可以在注释原来的地方替换为      or  ‘1’&#x3D;’1   来进行闭合，实行SQL注入</p><p>例如：preg_replace()函数则为过滤用。一般替换（不能用的字符）为空    。在这个函数中加&#x2F;i表示大小写都没法用</p><p><strong>2</strong> 如果过滤了 and 和 or，无法连接代码，可以用&amp;&amp;替换and，||替换or</p><p>注意：&amp;&amp;使用需要用url编码：%26%26。不编码的话当作多参数传参，无法生效。</p><p>sqli-labs第25关为例子  ，最后需要用information的库，但or会被替换为空，爆出来的结果为infmation，无法爆出所需要的表。所以这里可以采用双写绕过，在报错注入语句里写 from infoorrmation_schema  即可。</p><p><strong>3</strong> 过滤\s ：表示不能有空白      空格可以用%0a或者%a0来替换试试，也可以用select 后面多加个括号()来替换</p><p>例如sqli-labs第26关：payload为： ?id&#x3D;1’||(updatexml(1,concat(0x7e,(select(group_concat(table_name))from(infoorrmation_schema.tables)where(table_schema&#x3D;’security’))),1))||’0</p><p><strong>4</strong> 当union和select也被过滤时。先看是不是所有的大小写都被过滤，如果只是单独的，可以用selEct和uniOn来替换。</p><p>注意：查表的时候的单引号用database()函数代替，表名可以用十六进制来替代，因为MySQL支持16进制的表达。</p><h3 id="三-：基于burp-suite修改请求头来进行注入"><a href="#三-：基于burp-suite修改请求头来进行注入" class="headerlink" title="三 ：基于burp suite修改请求头来进行注入"></a>三 ：基于burp suite修改请求头来进行注入</h3><p>1 基于reference</p><p>2 基于cookie</p><p>3 基于X-forward</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>BUCCTF web</title>
      <link href="/2022/10/02/BUCCTF-web/"/>
      <url>/2022/10/02/BUCCTF-web/</url>
      
        <content type="html"><![CDATA[<hr><hr><h1 id="web-wp"><a href="#web-wp" class="headerlink" title="web wp"></a>web wp</h1><blockquote><p><img src="/2022/10/02/BUCCTF-web/EasySQL.png"></p></blockquote><p>根据题意，简单的SQL，进入界面，发现是一个简单的登录界面，所以随便输一个用户名：admin，密码用万能的： ‘ or 1&#x3D;1 ,flag就出来了</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
